//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const BH_API_BASE_URL = new InjectionToken<string>('BH_API_BASE_URL');

export class ApiClientBase {
    protected transformOptions(options: any) {
        options.headers = options.headers.append('Cache-Control', 'no-store');
        return Promise.resolve(options);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BHClient extends ApiClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BH_API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:5400';
    }

    /**
     * Get the audio recording for a given hearing.
     * @param hearingId The hearing id.
     * @return OK
     */
    getAudioRecordingLink(hearingId: string): Observable<HearingAudioRecordingResponse> {
        let url_ = this.baseUrl + '/api/audio/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAudioRecordingLink(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAudioRecordingLink(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingAudioRecordingResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingAudioRecordingResponse>;
                })
            );
    }

    protected processGetAudioRecordingLink(response: HttpResponseBase): Observable<HearingAudioRecordingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HearingAudioRecordingResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCvpAudioRecordingsAll(cloudroom: string, date: string, caseReference: string): Observable<CvpForAudioFileResponse[]> {
        let url_ = this.baseUrl + '/api/audio/cvp/all/{cloudroom}/{date}/{caseReference}';
        if (cloudroom === undefined || cloudroom === null) throw new Error("The parameter 'cloudroom' must be defined.");
        url_ = url_.replace('{cloudroom}', encodeURIComponent('' + cloudroom));
        if (date === undefined || date === null) throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace('{date}', encodeURIComponent('' + date));
        if (caseReference === undefined || caseReference === null) throw new Error("The parameter 'caseReference' must be defined.");
        url_ = url_.replace('{caseReference}', encodeURIComponent('' + caseReference));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCvpAudioRecordingsAll(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCvpAudioRecordingsAll(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<CvpForAudioFileResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<CvpForAudioFileResponse[]>;
                })
            );
    }

    protected processGetCvpAudioRecordingsAll(response: HttpResponseBase): Observable<CvpForAudioFileResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(CvpForAudioFileResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Gateway Timeout', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCvpAudioRecordingsByCloudRoom(cloudroom: string, date: string): Observable<CvpForAudioFileResponse[]> {
        let url_ = this.baseUrl + '/api/audio/cvp/cloudroom/{cloudroom}/{date}';
        if (cloudroom === undefined || cloudroom === null) throw new Error("The parameter 'cloudroom' must be defined.");
        url_ = url_.replace('{cloudroom}', encodeURIComponent('' + cloudroom));
        if (date === undefined || date === null) throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace('{date}', encodeURIComponent('' + date));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCvpAudioRecordingsByCloudRoom(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCvpAudioRecordingsByCloudRoom(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<CvpForAudioFileResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<CvpForAudioFileResponse[]>;
                })
            );
    }

    protected processGetCvpAudioRecordingsByCloudRoom(response: HttpResponseBase): Observable<CvpForAudioFileResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(CvpForAudioFileResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Gateway Timeout', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getCvpAudioRecordingsByDate(date: string, caseReference: string): Observable<CvpForAudioFileResponse[]> {
        let url_ = this.baseUrl + '/api/audio/cvp/date/{date}/{caseReference}';
        if (date === undefined || date === null) throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace('{date}', encodeURIComponent('' + date));
        if (caseReference === undefined || caseReference === null) throw new Error("The parameter 'caseReference' must be defined.");
        url_ = url_.replace('{caseReference}', encodeURIComponent('' + caseReference));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCvpAudioRecordingsByDate(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCvpAudioRecordingsByDate(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<CvpForAudioFileResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<CvpForAudioFileResponse[]>;
                })
            );
    }

    protected processGetCvpAudioRecordingsByDate(response: HttpResponseBase): Observable<CvpForAudioFileResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(CvpForAudioFileResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Gateway Timeout', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the all upcoming bookings hearing by the given case types for a hearing administrator.
     * @param body (optional)
     * @return OK
     */
    bookingsList(body: BookingSearchRequest | undefined): Observable<BookingsResponse> {
        let url_ = this.baseUrl + '/api/hearings/bookingsList';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processBookingsList(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processBookingsList(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BookingsResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BookingsResponse>;
                })
            );
    }

    protected processBookingsList(response: HttpResponseBase): Observable<BookingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = BookingsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Get the configuration settings for client
     * @return OK
     */
    getConfigSettings(): Observable<ClientSettingsResponse> {
        let url_ = this.baseUrl + '/api/config';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConfigSettings(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConfigSettings(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ClientSettingsResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ClientSettingsResponse>;
                })
            );
    }

    protected processGetConfigSettings(response: HttpResponseBase): Observable<ClientSettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ClientSettingsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getBookingQueueState(): Observable<AppHealthStatusResponse> {
        let url_ = this.baseUrl + '/api/health/bqs';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetBookingQueueState(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetBookingQueueState(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<AppHealthStatusResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<AppHealthStatusResponse>;
                })
            );
    }

    protected processGetBookingQueueState(response: HttpResponseBase): Observable<AppHealthStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = AppHealthStatusResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getHearingRoles(): Observable<HearingRoleResponse[]> {
        let url_ = this.baseUrl + '/api/hearingroles';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHearingRoles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHearingRoles(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingRoleResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingRoleResponse[]>;
                })
            );
    }

    protected processGetHearingRoles(response: HttpResponseBase): Observable<HearingRoleResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(HearingRoleResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create a hearing
     * @param body (optional) Hearing Request object
     * @return Created
     */
    bookNewHearing(body: BookHearingRequest | undefined): Observable<HearingDetailsResponse> {
        let url_ = this.baseUrl + '/api/hearings';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processBookNewHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processBookNewHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingDetailsResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingDetailsResponse>;
                })
            );
    }

    protected processBookNewHearing(response: HttpResponseBase): Observable<HearingDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    let resultData201 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = HearingDetailsResponse.fromJS(resultData201);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Rebook an existing hearing with a booking status of Failed
     * @param hearingId Id of the hearing with a status of Failed
     * @return No Content
     */
    rebookHearing(hearingId: string): Observable<void> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}/conferences';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processRebookHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processRebookHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processRebookHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return _observableOf(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Clone hearings with the details of a given hearing on given dates
     * @param hearingId Original hearing to clone
     * @param body (optional) The dates range to create the new hearings on
     * @return No Content
     */
    cloneHearing(hearingId: string, body: MultiHearingRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}/clone';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCloneHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCloneHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processCloneHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return _observableOf(null as any);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Edit a hearing
     * @param hearingId The id of the hearing to update
     * @param body (optional) Hearing Request object for edit operation
     * @return OK
     */
    editHearing(hearingId: string, body: EditHearingRequest | undefined): Observable<HearingDetailsResponse> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('put', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processEditHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processEditHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingDetailsResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingDetailsResponse>;
                })
            );
    }

    protected processEditHearing(response: HttpResponseBase): Observable<HearingDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HearingDetailsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('No Content', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Gets bookings hearing by Id.
     * @param hearingId The unique sequential value of hearing ID.
     * @return OK
     */
    getHearingById(hearingId: string): Observable<HearingDetailsResponse> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHearingById(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHearingById(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingDetailsResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingDetailsResponse>;
                })
            );
    }

    protected processGetHearingById(response: HttpResponseBase): Observable<HearingDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HearingDetailsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Edit a multi-day hearing
     * @param hearingId The id of the hearing
     * @param body (optional) Hearing Request object for edit operation
     * @return OK
     */
    editMultiDayHearing(hearingId: string, body: EditMultiDayHearingRequest | undefined): Observable<HearingDetailsResponse> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}/multi-day';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('put', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processEditMultiDayHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processEditMultiDayHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingDetailsResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingDetailsResponse>;
                })
            );
    }

    protected processEditMultiDayHearing(response: HttpResponseBase): Observable<HearingDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HearingDetailsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    cancelMultiDayHearing(hearingId: string, body: CancelMultiDayHearingRequest | undefined): Observable<UpdateBookingStatusResponse> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}/multi-day/cancel';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCancelMultiDayHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCancelMultiDayHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UpdateBookingStatusResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UpdateBookingStatusResponse>;
                })
            );
    }

    protected processCancelMultiDayHearing(response: HttpResponseBase): Observable<UpdateBookingStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UpdateBookingStatusResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Get hearings by case number.
     * @param caseNumber (optional) The case number.
     * @param date (optional) The date to filter by
     * @return OK
     */
    searchForAudioRecordedHearings(
        caseNumber: string | undefined,
        date: Date | undefined
    ): Observable<HearingsForAudioFileSearchResponse[]> {
        let url_ = this.baseUrl + '/api/hearings/audiorecording/search?';
        if (caseNumber === null) throw new Error("The parameter 'caseNumber' cannot be null.");
        else if (caseNumber !== undefined) url_ += 'caseNumber=' + encodeURIComponent('' + caseNumber) + '&';
        if (date === null) throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined) url_ += 'date=' + encodeURIComponent(date ? '' + date.toISOString() : '') + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSearchForAudioRecordedHearings(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSearchForAudioRecordedHearings(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingsForAudioFileSearchResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingsForAudioFileSearchResponse[]>;
                })
            );
    }

    protected processSearchForAudioRecordedHearings(response: HttpResponseBase): Observable<HearingsForAudioFileSearchResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(HearingsForAudioFileSearchResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Get the conference status.
     * @param hearingId The hearing id
     * @return OK
     */
    getHearingConferenceStatus(hearingId: string): Observable<UpdateBookingStatusResponse> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}/conference-status';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHearingConferenceStatus(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHearingConferenceStatus(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UpdateBookingStatusResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UpdateBookingStatusResponse>;
                })
            );
    }

    protected processGetHearingConferenceStatus(response: HttpResponseBase): Observable<UpdateBookingStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UpdateBookingStatusResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Cancel the booking
     * @param hearingId The hearing id
     * @param reason (optional) The reason the hearing has been cancelled
     * @return OK
     */
    cancelBooking(hearingId: string, reason: string | undefined): Observable<UpdateBookingStatusResponse> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}/cancel?';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        if (reason === null) throw new Error("The parameter 'reason' cannot be null.");
        else if (reason !== undefined) url_ += 'reason=' + encodeURIComponent('' + reason) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCancelBooking(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCancelBooking(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UpdateBookingStatusResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UpdateBookingStatusResponse>;
                })
            );
    }

    protected processCancelBooking(response: HttpResponseBase): Observable<UpdateBookingStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UpdateBookingStatusResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Update the failed hearing status.
     * @param hearingId The hearing id
     * @return OK
     */
    updateFailedBookingStatus(hearingId: string): Observable<UpdateBookingStatusResponse> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}/failed-status';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('put', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateFailedBookingStatus(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateFailedBookingStatus(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UpdateBookingStatusResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UpdateBookingStatusResponse>;
                })
            );
    }

    protected processUpdateFailedBookingStatus(response: HttpResponseBase): Observable<UpdateBookingStatusResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UpdateBookingStatusResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Gets for confirmed booking the telephone conference Id by hearing Id.
     * @param hearingId The unique sequential value of hearing ID.
     * @return OK
     */
    getTelephoneConferenceIdById(hearingId: string): Observable<PhoneConferenceResponse> {
        let url_ = this.baseUrl + '/api/hearings/{hearingId}/telephoneConferenceId';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTelephoneConferenceIdById(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTelephoneConferenceIdById(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<PhoneConferenceResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<PhoneConferenceResponse>;
                })
            );
    }

    protected processGetTelephoneConferenceIdById(response: HttpResponseBase): Observable<PhoneConferenceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PhoneConferenceResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a list hearing types
     * @return OK
     */
    getHearingTypes(): Observable<HearingTypeResponse[]> {
        let url_ = this.baseUrl + '/api/reference/types';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHearingTypes(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHearingTypes(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingTypeResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingTypeResponse[]>;
                })
            );
    }

    protected processGetHearingTypes(response: HttpResponseBase): Observable<HearingTypeResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(HearingTypeResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Get available courts
     * @return OK
     */
    getCourts(): Observable<HearingVenueResponse[]> {
        let url_ = this.baseUrl + '/api/reference/courts';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCourts(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCourts(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingVenueResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingVenueResponse[]>;
                })
            );
    }

    protected processGetCourts(response: HttpResponseBase): Observable<HearingVenueResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(HearingVenueResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Get available languages for interpreters
     * @return OK
     */
    getAvailableLanguages(): Observable<AvailableLanguageResponse[]> {
        let url_ = this.baseUrl + '/api/reference/available-languages';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAvailableLanguages(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAvailableLanguages(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<AvailableLanguageResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<AvailableLanguageResponse[]>;
                })
            );
    }

    protected processGetAvailableLanguages(response: HttpResponseBase): Observable<AvailableLanguageResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(AvailableLanguageResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Find judges and court rooms accounts list by email search term.
     * @param body (optional) The email address search term.
     * @return OK
     */
    postJudgesBySearchTerm(body: string | undefined): Observable<JudgeResponse[]> {
        let url_ = this.baseUrl + '/api/judiciary/judges';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processPostJudgesBySearchTerm(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processPostJudgesBySearchTerm(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<JudgeResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<JudgeResponse[]>;
                })
            );
    }

    protected processPostJudgesBySearchTerm(response: HttpResponseBase): Observable<JudgeResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(JudgeResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Find judiciary person list by email search term.
     * @param body (optional) The email address search term.
     * @return OK
     */
    searchForJudiciaryPerson(body: string | undefined): Observable<JudiciaryPerson[]> {
        let url_ = this.baseUrl + '/api/judiciary/search';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSearchForJudiciaryPerson(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSearchForJudiciaryPerson(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<JudiciaryPerson[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<JudiciaryPerson[]>;
                })
            );
    }

    protected processSearchForJudiciaryPerson(response: HttpResponseBase): Observable<JudiciaryPerson[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(JudiciaryPerson.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Add a new justice user
     * @param body (optional)
     * @return Created
     */
    addNewJusticeUser(body: AddNewJusticeUserRequest | undefined): Observable<JusticeUserResponse> {
        let url_ = this.baseUrl + '/api/justice-users';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddNewJusticeUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddNewJusticeUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<JusticeUserResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<JusticeUserResponse>;
                })
            );
    }

    protected processAddNewJusticeUser(response: HttpResponseBase): Observable<JusticeUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    let resultData201 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = JusticeUserResponse.fromJS(resultData201);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result409: any = null;
                    let resultData409 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result409 = resultData409 !== undefined ? resultData409 : <any>null;

                    return throwException('Conflict', status, _responseText, _headers, result409);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    editJusticeUser(body: EditJusticeUserRequest | undefined): Observable<JusticeUserResponse> {
        let url_ = this.baseUrl + '/api/justice-users';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processEditJusticeUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processEditJusticeUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<JusticeUserResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<JusticeUserResponse>;
                })
            );
    }

    protected processEditJusticeUser(response: HttpResponseBase): Observable<JusticeUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = JusticeUserResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : <any>null;

                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a justice user
     * @param id The justice user id
     * @return No Content
     */
    deleteJusticeUser(id: string): Observable<string> {
        let url_ = this.baseUrl + '/api/justice-users/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('delete', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteJusticeUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteJusticeUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<string>;
                        }
                    } else return _observableThrow(response_) as any as Observable<string>;
                })
            );
    }

    protected processDeleteJusticeUser(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    let resultData204 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result204 = resultData204 !== undefined ? resultData204 : <any>null;

                    return _observableOf(result204);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : <any>null;

                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    restoreJusticeUser(body: RestoreJusticeUserRequest | undefined): Observable<JusticeUserResponse> {
        let url_ = this.baseUrl + '/api/justice-users/restore';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processRestoreJusticeUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processRestoreJusticeUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<JusticeUserResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<JusticeUserResponse>;
                })
            );
    }

    protected processRestoreJusticeUser(response: HttpResponseBase): Observable<JusticeUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = JusticeUserResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : <any>null;

                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Find person list by email search term.
     * @param body (optional) The email address search term.
     * @return OK
     */
    postPersonBySearchTerm(body: string | undefined): Observable<PersonResponseV2[]> {
        let url_ = this.baseUrl + '/api/persons';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processPostPersonBySearchTerm(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processPostPersonBySearchTerm(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<PersonResponseV2[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<PersonResponseV2[]>;
                })
            );
    }

    protected processPostPersonBySearchTerm(response: HttpResponseBase): Observable<PersonResponseV2[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(PersonResponseV2.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Search for non judge persons by contact email
     * @param contactEmail (optional)
     * @return OK
     */
    getPersonForUpdateByContactEmail(contactEmail: string | undefined): Observable<PersonResponseV2> {
        let url_ = this.baseUrl + '/api/persons?';
        if (contactEmail === null) throw new Error("The parameter 'contactEmail' cannot be null.");
        else if (contactEmail !== undefined) url_ += 'contactEmail=' + encodeURIComponent('' + contactEmail) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetPersonForUpdateByContactEmail(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetPersonForUpdateByContactEmail(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<PersonResponseV2>;
                        }
                    } else return _observableThrow(response_) as any as Observable<PersonResponseV2>;
                })
            );
    }

    protected processGetPersonForUpdateByContactEmail(response: HttpResponseBase): Observable<PersonResponseV2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = PersonResponseV2.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Get all hearings for a person by username
     * @param username (optional)
     * @return OK
     */
    getHearingsByUsernameForDeletion(username: string | undefined): Observable<HearingsByUsernameForDeletionResponse[]> {
        let url_ = this.baseUrl + '/api/persons/username/hearings?';
        if (username === null) throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined) url_ += 'username=' + encodeURIComponent('' + username) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHearingsByUsernameForDeletion(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHearingsByUsernameForDeletion(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingsByUsernameForDeletionResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingsByUsernameForDeletionResponse[]>;
                })
            );
    }

    protected processGetHearingsByUsernameForDeletion(response: HttpResponseBase): Observable<HearingsByUsernameForDeletionResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(HearingsByUsernameForDeletionResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a user account and anonymise a person in bookings
     * @param username username of person
     * @return No Content
     */
    deletePersonWithUsername(username: string): Observable<void> {
        let url_ = this.baseUrl + '/api/persons/username/{username}';
        if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace('{username}', encodeURIComponent('' + username));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('delete', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeletePersonWithUsername(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeletePersonWithUsername(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processDeletePersonWithUsername(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return _observableOf(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Update the personal details
     * @param personId The id of the person to update
     * @param body (optional) Updated details of the person
     * @return Accepted
     */
    updatePersonDetails(personId: string, body: UpdateAccountDetailsRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/api/persons/{personId}';
        if (personId === undefined || personId === null) throw new Error("The parameter 'personId' must be defined.");
        url_ = url_.replace('{personId}', encodeURIComponent('' + personId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('put', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdatePersonDetails(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdatePersonDetails(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processUpdatePersonDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return _observableOf(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Search Judges by email
     * @param term (optional)
     * @return OK
     */
    searchJudgesByEmail(term: string | undefined): Observable<JudgeResponse[]> {
        let url_ = this.baseUrl + '/api/accounts/judges/search/email?';
        if (term === null) throw new Error("The parameter 'term' cannot be null.");
        else if (term !== undefined) url_ += 'term=' + encodeURIComponent('' + term) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSearchJudgesByEmail(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSearchJudgesByEmail(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<JudgeResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<JudgeResponse[]>;
                })
            );
    }

    protected processSearchJudgesByEmail(response: HttpResponseBase): Observable<JudgeResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(JudgeResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Not Found', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Updates the users AAD password.
     * @param body (optional)
     * @return OK
     */
    resetPassword(body: string | undefined): Observable<void> {
        let url_ = this.baseUrl + '/api/accounts/resetpassword';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processResetPassword(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processResetPassword(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return _observableOf(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Not Found', status, _responseText, _headers);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Bad Request', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUserProfile(): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/api/user';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserProfile(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserProfile(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserProfileResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserProfileResponse>;
                })
            );
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : <any>null;

                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Get list of Justice User filtered by term. If term is null then no filter applied.
     * @param term (optional) term to filter result
     * @return OK
     */
    getUserList(term: string | undefined): Observable<JusticeUserResponse[]> {
        let url_ = this.baseUrl + '/api/user/list?';
        if (term === null) throw new Error("The parameter 'term' cannot be null.");
        else if (term !== undefined) url_ += 'term=' + encodeURIComponent('' + term) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserList(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserList(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<JusticeUserResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<JusticeUserResponse[]>;
                })
            );
    }

    protected processGetUserList(response: HttpResponseBase): Observable<JusticeUserResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(JusticeUserResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getUnallocatedHearings(): Observable<UnallocatedHearingsForVhoResponse> {
        let url_ = this.baseUrl + '/api/work-allocation/unallocated';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUnallocatedHearings(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUnallocatedHearings(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UnallocatedHearingsForVhoResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UnallocatedHearingsForVhoResponse>;
                })
            );
    }

    protected processGetUnallocatedHearings(response: HttpResponseBase): Observable<UnallocatedHearingsForVhoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnallocatedHearingsForVhoResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param cso (optional)
     * @param caseType (optional)
     * @param caseNumber (optional)
     * @param isUnallocated (optional)
     * @return OK
     */
    getAllocationHearings(
        fromDate: Date | undefined,
        toDate: Date | undefined,
        cso: string[] | undefined,
        caseType: string[] | undefined,
        caseNumber: string | undefined,
        isUnallocated: boolean | undefined
    ): Observable<AllocationHearingsResponse[]> {
        let url_ = this.baseUrl + '/api/work-allocation/allocation?';
        if (fromDate === null) throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined) url_ += 'FromDate=' + encodeURIComponent(fromDate ? '' + fromDate.toISOString() : '') + '&';
        if (toDate === null) throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined) url_ += 'ToDate=' + encodeURIComponent(toDate ? '' + toDate.toISOString() : '') + '&';
        if (cso === null) throw new Error("The parameter 'cso' cannot be null.");
        else if (cso !== undefined)
            cso &&
                cso.forEach(item => {
                    url_ += 'Cso=' + encodeURIComponent('' + item) + '&';
                });
        if (caseType === null) throw new Error("The parameter 'caseType' cannot be null.");
        else if (caseType !== undefined)
            caseType &&
                caseType.forEach(item => {
                    url_ += 'CaseType=' + encodeURIComponent('' + item) + '&';
                });
        if (caseNumber === null) throw new Error("The parameter 'caseNumber' cannot be null.");
        else if (caseNumber !== undefined) url_ += 'CaseNumber=' + encodeURIComponent('' + caseNumber) + '&';
        if (isUnallocated === null) throw new Error("The parameter 'isUnallocated' cannot be null.");
        else if (isUnallocated !== undefined) url_ += 'IsUnallocated=' + encodeURIComponent('' + isUnallocated) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAllocationHearings(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAllocationHearings(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<AllocationHearingsResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<AllocationHearingsResponse[]>;
                })
            );
    }

    protected processGetAllocationHearings(response: HttpResponseBase): Observable<AllocationHearingsResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(AllocationHearingsResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Update the hearing status.
     * @param body (optional)
     * @return OK
     */
    allocateHearingsToCso(body: UpdateHearingAllocationToCsoRequest | undefined): Observable<AllocationHearingsResponse[]> {
        let url_ = this.baseUrl + '/api/work-allocation/allocations';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAllocateHearingsToCso(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAllocateHearingsToCso(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<AllocationHearingsResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<AllocationHearingsResponse[]>;
                })
            );
    }

    protected processAllocateHearingsToCso(response: HttpResponseBase): Observable<AllocationHearingsResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(AllocationHearingsResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    uploadWorkHours(body: UploadWorkHoursRequest[] | undefined): Observable<UploadWorkHoursResponse> {
        let url_ = this.baseUrl + '/api/workhours/UploadWorkHours';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUploadWorkHours(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUploadWorkHours(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UploadWorkHoursResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UploadWorkHoursResponse>;
                })
            );
    }

    protected processUploadWorkHours(response: HttpResponseBase): Observable<UploadWorkHoursResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UploadWorkHoursResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return OK
     */
    uploadNonWorkingHours(body: UploadNonWorkingHoursRequest[] | undefined): Observable<UploadNonWorkingHoursResponse> {
        let url_ = this.baseUrl + '/api/workhours/UploadNonWorkingHours';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUploadNonWorkingHours(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUploadNonWorkingHours(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UploadNonWorkingHoursResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UploadNonWorkingHoursResponse>;
                })
            );
    }

    protected processUploadNonWorkingHours(response: HttpResponseBase): Observable<UploadNonWorkingHoursResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UploadNonWorkingHoursResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @param vho (optional)
     * @return OK
     */
    getWorkAvailabilityHours(vho: string | undefined): Observable<VhoWorkHoursResponse[]> {
        let url_ = this.baseUrl + '/api/workhours/VHO?';
        if (vho === null) throw new Error("The parameter 'vho' cannot be null.");
        else if (vho !== undefined) url_ += 'vho=' + encodeURIComponent('' + vho) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetWorkAvailabilityHours(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetWorkAvailabilityHours(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<VhoWorkHoursResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<VhoWorkHoursResponse[]>;
                })
            );
    }

    protected processGetWorkAvailabilityHours(response: HttpResponseBase): Observable<VhoWorkHoursResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(VhoWorkHoursResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Bad Request', status, _responseText, _headers);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Not Found', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @param vho (optional)
     * @return OK
     */
    getNonAvailabilityWorkHours(vho: string | undefined): Observable<VhoNonAvailabilityWorkHoursResponse[]> {
        let url_ = this.baseUrl + '/api/workhours/NonAvailability/VHO?';
        if (vho === null) throw new Error("The parameter 'vho' cannot be null.");
        else if (vho !== undefined) url_ += 'vho=' + encodeURIComponent('' + vho) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNonAvailabilityWorkHours(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNonAvailabilityWorkHours(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<VhoNonAvailabilityWorkHoursResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<VhoNonAvailabilityWorkHoursResponse[]>;
                })
            );
    }

    protected processGetNonAvailabilityWorkHours(response: HttpResponseBase): Observable<VhoNonAvailabilityWorkHoursResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(VhoNonAvailabilityWorkHoursResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Bad Request', status, _responseText, _headers);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Not Found', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Updates non availability hours for a vho
     * @param body (optional)
     * @return No Content
     */
    updateNonAvailabilityWorkHours(username: string, body: UpdateNonWorkingHoursRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/api/workhours/NonAvailability/VHO/{username}';
        if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace('{username}', encodeURIComponent('' + username));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateNonAvailabilityWorkHours(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateNonAvailabilityWorkHours(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processUpdateNonAvailabilityWorkHours(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return _observableOf(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    deleteNonAvailabilityWorkHours(username: string, nonAvailabilityId: number): Observable<void> {
        let url_ = this.baseUrl + '/api/workhours/NonAvailability/{username}/{nonAvailabilityId}';
        if (username === undefined || username === null) throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace('{username}', encodeURIComponent('' + username));
        if (nonAvailabilityId === undefined || nonAvailabilityId === null)
            throw new Error("The parameter 'nonAvailabilityId' must be defined.");
        url_ = url_.replace('{nonAvailabilityId}', encodeURIComponent('' + nonAvailabilityId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('delete', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteNonAvailabilityWorkHours(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteNonAvailabilityWorkHours(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processDeleteNonAvailabilityWorkHours(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = UnexpectedErrorResponse.fromJS(resultData500);
                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return _observableOf(null as any);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Bad Request', status, _responseText, _headers);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Not Found', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }
}

export enum BookingStatus {
    Booked = 'Booked',
    Created = 'Created',
    Cancelled = 'Cancelled',
    Failed = 'Failed',
    BookedWithoutJudge = 'BookedWithoutJudge',
    ConfirmedWithoutJudge = 'ConfirmedWithoutJudge'
}

export enum InterprepretationType {
    Sign = 'Sign',
    Verbal = 'Verbal'
}

export enum JudgeAccountType {
    Courtroom = 'Courtroom',
    Judiciary = 'Judiciary'
}

export enum LinkedParticipantType {
    Interpreter = 'Interpreter'
}

export enum ScreeningType {
    All = 'All',
    Specific = 'Specific'
}

export enum VideoSupplier {
    Kinly = 'Kinly',
    Vodafone = 'Vodafone'
}

/** Create a new Justice User */
export class AddNewJusticeUserRequest implements IAddNewJusticeUserRequest {
    /** The user's first name */
    first_name?: string | undefined;
    /** The user's last name */
    last_name?: string | undefined;
    /** The user's username */
    username?: string | undefined;
    /** The user's telephone */
    contact_telephone?: string | undefined;
    /** The user's role. This can be a VHO or a Team Lead. */
    roles?: JusticeUserRole[] | undefined;

    constructor(data?: IAddNewJusticeUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.username = _data['username'];
            this.contact_telephone = _data['contact_telephone'];
            if (Array.isArray(_data['roles'])) {
                this.roles = [] as any;
                for (let item of _data['roles']) this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AddNewJusticeUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewJusticeUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['username'] = this.username;
        data['contact_telephone'] = this.contact_telephone;
        if (Array.isArray(this.roles)) {
            data['roles'] = [];
            for (let item of this.roles) data['roles'].push(item);
        }
        return data;
    }
}

/** Create a new Justice User */
export interface IAddNewJusticeUserRequest {
    /** The user's first name */
    first_name?: string | undefined;
    /** The user's last name */
    last_name?: string | undefined;
    /** The user's username */
    username?: string | undefined;
    /** The user's telephone */
    contact_telephone?: string | undefined;
    /** The user's role. This can be a VHO or a Team Lead. */
    roles?: JusticeUserRole[] | undefined;
}

export class BookHearingRequest implements IBookHearingRequest {
    booking_details?: BookingDetailsRequest;
    is_multi_day?: boolean;
    multi_hearing_details?: MultiHearingRequest;
    other_information_details?: string | undefined;

    constructor(data?: IBookHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.booking_details = _data['booking_details'] ? BookingDetailsRequest.fromJS(_data['booking_details']) : <any>undefined;
            this.is_multi_day = _data['is_multi_day'];
            this.multi_hearing_details = _data['multi_hearing_details']
                ? MultiHearingRequest.fromJS(_data['multi_hearing_details'])
                : <any>undefined;
            this.other_information_details = _data['other_information_details'];
        }
    }

    static fromJS(data: any): BookHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BookHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['booking_details'] = this.booking_details ? this.booking_details.toJSON() : <any>undefined;
        data['is_multi_day'] = this.is_multi_day;
        data['multi_hearing_details'] = this.multi_hearing_details ? this.multi_hearing_details.toJSON() : <any>undefined;
        data['other_information_details'] = this.other_information_details;
        return data;
    }
}

export interface IBookHearingRequest {
    booking_details?: BookingDetailsRequest;
    is_multi_day?: boolean;
    multi_hearing_details?: MultiHearingRequest;
    other_information_details?: string | undefined;
}

export class BookingDetailsRequest implements IBookingDetailsRequest {
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    hearing_venue_code?: string | undefined;
    case_type_service_id?: string | undefined;
    cases?: CaseRequest[] | undefined;
    participants?: ParticipantRequest[] | undefined;
    judiciary_participants?: JudiciaryParticipantRequest[] | undefined;
    hearing_room_name?: string | undefined;
    other_information?: string | undefined;
    created_by?: string | undefined;
    audio_recording_required?: boolean;
    is_multi_day_hearing?: boolean;
    conference_supplier?: VideoSupplier;
    endpoints?: EndpointRequest[] | undefined;
    linked_participants?: LinkedParticipantRequest[] | undefined;

    constructor(data?: IBookingDetailsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.is_multi_day_hearing = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.hearing_venue_code = _data['hearing_venue_code'];
            this.case_type_service_id = _data['case_type_service_id'];
            if (Array.isArray(_data['cases'])) {
                this.cases = [] as any;
                for (let item of _data['cases']) this.cases!.push(CaseRequest.fromJS(item));
            }
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantRequest.fromJS(item));
            }
            if (Array.isArray(_data['judiciary_participants'])) {
                this.judiciary_participants = [] as any;
                for (let item of _data['judiciary_participants'])
                    this.judiciary_participants!.push(JudiciaryParticipantRequest.fromJS(item));
            }
            this.hearing_room_name = _data['hearing_room_name'];
            this.other_information = _data['other_information'];
            this.created_by = _data['created_by'];
            this.audio_recording_required = _data['audio_recording_required'];
            this.is_multi_day_hearing = _data['is_multi_day_hearing'] !== undefined ? _data['is_multi_day_hearing'] : false;
            this.conference_supplier = _data['conference_supplier'];
            if (Array.isArray(_data['endpoints'])) {
                this.endpoints = [] as any;
                for (let item of _data['endpoints']) this.endpoints!.push(EndpointRequest.fromJS(item));
            }
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BookingDetailsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BookingDetailsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['hearing_venue_code'] = this.hearing_venue_code;
        data['case_type_service_id'] = this.case_type_service_id;
        if (Array.isArray(this.cases)) {
            data['cases'] = [];
            for (let item of this.cases) data['cases'].push(item.toJSON());
        }
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        if (Array.isArray(this.judiciary_participants)) {
            data['judiciary_participants'] = [];
            for (let item of this.judiciary_participants) data['judiciary_participants'].push(item.toJSON());
        }
        data['hearing_room_name'] = this.hearing_room_name;
        data['other_information'] = this.other_information;
        data['created_by'] = this.created_by;
        data['audio_recording_required'] = this.audio_recording_required;
        data['is_multi_day_hearing'] = this.is_multi_day_hearing;
        data['conference_supplier'] = this.conference_supplier;
        if (Array.isArray(this.endpoints)) {
            data['endpoints'] = [];
            for (let item of this.endpoints) data['endpoints'].push(item.toJSON());
        }
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IBookingDetailsRequest {
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    hearing_venue_code?: string | undefined;
    case_type_service_id?: string | undefined;
    cases?: CaseRequest[] | undefined;
    participants?: ParticipantRequest[] | undefined;
    judiciary_participants?: JudiciaryParticipantRequest[] | undefined;
    hearing_room_name?: string | undefined;
    other_information?: string | undefined;
    created_by?: string | undefined;
    audio_recording_required?: boolean;
    is_multi_day_hearing?: boolean;
    conference_supplier?: VideoSupplier;
    endpoints?: EndpointRequest[] | undefined;
    linked_participants?: LinkedParticipantRequest[] | undefined;
}

export class BookingSearchRequest implements IBookingSearchRequest {
    cursor?: string | undefined;
    limit!: number;
    caseNumber?: string | undefined;
    venueIds?: number[] | undefined;
    caseTypes?: string[] | undefined;
    selectedUsers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    lastName?: string | undefined;
    noJudge!: boolean;
    noAllocated!: boolean;

    constructor(data?: IBookingSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cursor = _data['cursor'];
            this.limit = _data['limit'];
            this.caseNumber = _data['caseNumber'];
            if (Array.isArray(_data['venueIds'])) {
                this.venueIds = [] as any;
                for (let item of _data['venueIds']) this.venueIds!.push(item);
            }
            if (Array.isArray(_data['caseTypes'])) {
                this.caseTypes = [] as any;
                for (let item of _data['caseTypes']) this.caseTypes!.push(item);
            }
            if (Array.isArray(_data['selectedUsers'])) {
                this.selectedUsers = [] as any;
                for (let item of _data['selectedUsers']) this.selectedUsers!.push(item);
            }
            this.startDate = _data['startDate'] ? new Date(_data['startDate'].toString()) : <any>undefined;
            this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
            this.lastName = _data['lastName'];
            this.noJudge = _data['noJudge'];
            this.noAllocated = _data['noAllocated'];
        }
    }

    static fromJS(data: any): BookingSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BookingSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['cursor'] = this.cursor;
        data['limit'] = this.limit;
        data['caseNumber'] = this.caseNumber;
        if (Array.isArray(this.venueIds)) {
            data['venueIds'] = [];
            for (let item of this.venueIds) data['venueIds'].push(item);
        }
        if (Array.isArray(this.caseTypes)) {
            data['caseTypes'] = [];
            for (let item of this.caseTypes) data['caseTypes'].push(item);
        }
        if (Array.isArray(this.selectedUsers)) {
            data['selectedUsers'] = [];
            for (let item of this.selectedUsers) data['selectedUsers'].push(item);
        }
        data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data['lastName'] = this.lastName;
        data['noJudge'] = this.noJudge;
        data['noAllocated'] = this.noAllocated;
        return data;
    }
}

export interface IBookingSearchRequest {
    cursor?: string | undefined;
    limit: number;
    caseNumber?: string | undefined;
    venueIds?: number[] | undefined;
    caseTypes?: string[] | undefined;
    selectedUsers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    lastName?: string | undefined;
    noJudge: boolean;
    noAllocated: boolean;
}

export class CancelMultiDayHearingRequest implements ICancelMultiDayHearingRequest {
    /** When true, applies updates to future days of the multi day hearing as well */
    update_future_days?: boolean;
    /** The reason for cancelling the video hearing */
    cancel_reason?: string | undefined;

    constructor(data?: ICancelMultiDayHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.update_future_days = _data['update_future_days'];
            this.cancel_reason = _data['cancel_reason'];
        }
    }

    static fromJS(data: any): CancelMultiDayHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CancelMultiDayHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['update_future_days'] = this.update_future_days;
        data['cancel_reason'] = this.cancel_reason;
        return data;
    }
}

export interface ICancelMultiDayHearingRequest {
    /** When true, applies updates to future days of the multi day hearing as well */
    update_future_days?: boolean;
    /** The reason for cancelling the video hearing */
    cancel_reason?: string | undefined;
}

export class CaseRequest implements ICaseRequest {
    number?: string | undefined;
    name?: string | undefined;
    is_lead_case?: boolean;

    constructor(data?: ICaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data['number'];
            this.name = _data['name'];
            this.is_lead_case = _data['is_lead_case'];
        }
    }

    static fromJS(data: any): CaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['number'] = this.number;
        data['name'] = this.name;
        data['is_lead_case'] = this.is_lead_case;
        return data;
    }
}

export interface ICaseRequest {
    number?: string | undefined;
    name?: string | undefined;
    is_lead_case?: boolean;
}

export class EditMultiDayHearingRequest implements IEditMultiDayHearingRequest {
    /** Duration of the hearing */
    scheduled_duration?: number;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** The code of the hearing venue */
    hearing_venue_code?: string | undefined;
    /** The hearing room name at the hearing venue */
    hearing_room_name?: string | undefined;
    /** Any other information about the hearing */
    other_information?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** Gets or sets the audio recording required flag, value true  is indicated that recording is required, otherwise false */
    audio_recording_required?: boolean;
    /** List of participants in hearing */
    participants?: EditParticipantRequest[] | undefined;
    /** List of judiciary participants in hearing */
    judiciary_participants?: JudiciaryParticipantRequest[] | undefined;
    /** List of endpoints for the hearing */
    endpoints?: EditEndpointRequest[] | undefined;
    /** Details specific to each hearing in the multi day group */
    hearings_in_group?: UpdateHearingInGroupRequest[] | undefined;
    /** When true, applies updates to future days of the multi day hearing as well */
    update_future_days?: boolean;

    constructor(data?: IEditMultiDayHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduled_duration = _data['scheduled_duration'];
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.hearing_venue_code = _data['hearing_venue_code'];
            this.hearing_room_name = _data['hearing_room_name'];
            this.other_information = _data['other_information'];
            this.case_number = _data['case_number'];
            this.audio_recording_required = _data['audio_recording_required'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(EditParticipantRequest.fromJS(item));
            }
            if (Array.isArray(_data['judiciary_participants'])) {
                this.judiciary_participants = [] as any;
                for (let item of _data['judiciary_participants'])
                    this.judiciary_participants!.push(JudiciaryParticipantRequest.fromJS(item));
            }
            if (Array.isArray(_data['endpoints'])) {
                this.endpoints = [] as any;
                for (let item of _data['endpoints']) this.endpoints!.push(EditEndpointRequest.fromJS(item));
            }
            if (Array.isArray(_data['hearings_in_group'])) {
                this.hearings_in_group = [] as any;
                for (let item of _data['hearings_in_group']) this.hearings_in_group!.push(UpdateHearingInGroupRequest.fromJS(item));
            }
            this.update_future_days = _data['update_future_days'];
        }
    }

    static fromJS(data: any): EditMultiDayHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditMultiDayHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['scheduled_duration'] = this.scheduled_duration;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['hearing_venue_code'] = this.hearing_venue_code;
        data['hearing_room_name'] = this.hearing_room_name;
        data['other_information'] = this.other_information;
        data['case_number'] = this.case_number;
        data['audio_recording_required'] = this.audio_recording_required;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        if (Array.isArray(this.judiciary_participants)) {
            data['judiciary_participants'] = [];
            for (let item of this.judiciary_participants) data['judiciary_participants'].push(item.toJSON());
        }
        if (Array.isArray(this.endpoints)) {
            data['endpoints'] = [];
            for (let item of this.endpoints) data['endpoints'].push(item.toJSON());
        }
        if (Array.isArray(this.hearings_in_group)) {
            data['hearings_in_group'] = [];
            for (let item of this.hearings_in_group) data['hearings_in_group'].push(item.toJSON());
        }
        data['update_future_days'] = this.update_future_days;
        return data;
    }
}

export interface IEditMultiDayHearingRequest {
    /** Duration of the hearing */
    scheduled_duration?: number;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** The code of the hearing venue */
    hearing_venue_code?: string | undefined;
    /** The hearing room name at the hearing venue */
    hearing_room_name?: string | undefined;
    /** Any other information about the hearing */
    other_information?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** Gets or sets the audio recording required flag, value true  is indicated that recording is required, otherwise false */
    audio_recording_required?: boolean;
    /** List of participants in hearing */
    participants?: EditParticipantRequest[] | undefined;
    /** List of judiciary participants in hearing */
    judiciary_participants?: JudiciaryParticipantRequest[] | undefined;
    /** List of endpoints for the hearing */
    endpoints?: EditEndpointRequest[] | undefined;
    /** Details specific to each hearing in the multi day group */
    hearings_in_group?: UpdateHearingInGroupRequest[] | undefined;
    /** When true, applies updates to future days of the multi day hearing as well */
    update_future_days?: boolean;
}

export class EndpointRequest implements IEndpointRequest {
    display_name?: string | undefined;
    external_reference_id?: string | undefined;
    defence_advocate_contact_email?: string | undefined;
    interpreter_language_code?: string | undefined;
    screening_requirements?: SpecialMeasureScreeningRequest;

    constructor(data?: IEndpointRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.display_name = _data['display_name'];
            this.external_reference_id = _data['external_reference_id'];
            this.defence_advocate_contact_email = _data['defence_advocate_contact_email'];
            this.interpreter_language_code = _data['interpreter_language_code'];
            this.screening_requirements = _data['screening_requirements']
                ? SpecialMeasureScreeningRequest.fromJS(_data['screening_requirements'])
                : <any>undefined;
        }
    }

    static fromJS(data: any): EndpointRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EndpointRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['display_name'] = this.display_name;
        data['external_reference_id'] = this.external_reference_id;
        data['defence_advocate_contact_email'] = this.defence_advocate_contact_email;
        data['interpreter_language_code'] = this.interpreter_language_code;
        data['screening_requirements'] = this.screening_requirements ? this.screening_requirements.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEndpointRequest {
    display_name?: string | undefined;
    external_reference_id?: string | undefined;
    defence_advocate_contact_email?: string | undefined;
    interpreter_language_code?: string | undefined;
    screening_requirements?: SpecialMeasureScreeningRequest;
}

export class JudiciaryParticipantRequest implements IJudiciaryParticipantRequest {
    personal_code?: string | undefined;
    role?: string | undefined;
    display_name?: string | undefined;
    optional_contact_telephone?: string | undefined;
    optional_contact_email?: string | undefined;
    interpreter_language_code?: string | undefined;

    constructor(data?: IJudiciaryParticipantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personal_code = _data['personal_code'];
            this.role = _data['role'];
            this.display_name = _data['display_name'];
            this.optional_contact_telephone = _data['optional_contact_telephone'];
            this.optional_contact_email = _data['optional_contact_email'];
            this.interpreter_language_code = _data['interpreter_language_code'];
        }
    }

    static fromJS(data: any): JudiciaryParticipantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JudiciaryParticipantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['personal_code'] = this.personal_code;
        data['role'] = this.role;
        data['display_name'] = this.display_name;
        data['optional_contact_telephone'] = this.optional_contact_telephone;
        data['optional_contact_email'] = this.optional_contact_email;
        data['interpreter_language_code'] = this.interpreter_language_code;
        return data;
    }
}

export interface IJudiciaryParticipantRequest {
    personal_code?: string | undefined;
    role?: string | undefined;
    display_name?: string | undefined;
    optional_contact_telephone?: string | undefined;
    optional_contact_email?: string | undefined;
    interpreter_language_code?: string | undefined;
}

export class LinkedParticipantRequest implements ILinkedParticipantRequest {
    participant_contact_email?: string | undefined;
    linked_participant_contact_email?: string | undefined;
    type?: LinkedParticipantType;

    constructor(data?: ILinkedParticipantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_contact_email = _data['participant_contact_email'];
            this.linked_participant_contact_email = _data['linked_participant_contact_email'];
            this.type = _data['type'];
        }
    }

    static fromJS(data: any): LinkedParticipantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedParticipantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_contact_email'] = this.participant_contact_email;
        data['linked_participant_contact_email'] = this.linked_participant_contact_email;
        data['type'] = this.type;
        return data;
    }
}

export interface ILinkedParticipantRequest {
    participant_contact_email?: string | undefined;
    linked_participant_contact_email?: string | undefined;
    type?: LinkedParticipantType;
}

export class ParticipantRequest implements IParticipantRequest {
    external_reference_id?: string | undefined;
    title?: string | undefined;
    first_name?: string | undefined;
    middle_names?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    telephone_number?: string | undefined;
    username?: string | undefined;
    display_name?: string | undefined;
    hearing_role_code?: string | undefined;
    representee?: string | undefined;
    organisation_name?: string | undefined;
    interpreter_language_code?: string | undefined;
    screening_requirements?: SpecialMeasureScreeningRequest;

    constructor(data?: IParticipantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.external_reference_id = _data['external_reference_id'];
            this.title = _data['title'];
            this.first_name = _data['first_name'];
            this.middle_names = _data['middle_names'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.telephone_number = _data['telephone_number'];
            this.username = _data['username'];
            this.display_name = _data['display_name'];
            this.hearing_role_code = _data['hearing_role_code'];
            this.representee = _data['representee'];
            this.organisation_name = _data['organisation_name'];
            this.interpreter_language_code = _data['interpreter_language_code'];
            this.screening_requirements = _data['screening_requirements']
                ? SpecialMeasureScreeningRequest.fromJS(_data['screening_requirements'])
                : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['external_reference_id'] = this.external_reference_id;
        data['title'] = this.title;
        data['first_name'] = this.first_name;
        data['middle_names'] = this.middle_names;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['telephone_number'] = this.telephone_number;
        data['username'] = this.username;
        data['display_name'] = this.display_name;
        data['hearing_role_code'] = this.hearing_role_code;
        data['representee'] = this.representee;
        data['organisation_name'] = this.organisation_name;
        data['interpreter_language_code'] = this.interpreter_language_code;
        data['screening_requirements'] = this.screening_requirements ? this.screening_requirements.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipantRequest {
    external_reference_id?: string | undefined;
    title?: string | undefined;
    first_name?: string | undefined;
    middle_names?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    telephone_number?: string | undefined;
    username?: string | undefined;
    display_name?: string | undefined;
    hearing_role_code?: string | undefined;
    representee?: string | undefined;
    organisation_name?: string | undefined;
    interpreter_language_code?: string | undefined;
    screening_requirements?: SpecialMeasureScreeningRequest;
}

/** Screening requirements for a participant */
export class SpecialMeasureScreeningRequest implements ISpecialMeasureScreeningRequest {
    /** True if screen from all, or false if screen from specific participants */
    screen_all?: boolean;
    /** List of participant/endpoint external reference ids to screen from */
    screen_from_external_reference_ids?: string[] | undefined;

    constructor(data?: ISpecialMeasureScreeningRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.screen_all = _data['screen_all'];
            if (Array.isArray(_data['screen_from_external_reference_ids'])) {
                this.screen_from_external_reference_ids = [] as any;
                for (let item of _data['screen_from_external_reference_ids']) this.screen_from_external_reference_ids!.push(item);
            }
        }
    }

    static fromJS(data: any): SpecialMeasureScreeningRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialMeasureScreeningRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['screen_all'] = this.screen_all;
        if (Array.isArray(this.screen_from_external_reference_ids)) {
            data['screen_from_external_reference_ids'] = [];
            for (let item of this.screen_from_external_reference_ids) data['screen_from_external_reference_ids'].push(item);
        }
        return data;
    }
}

/** Screening requirements for a participant */
export interface ISpecialMeasureScreeningRequest {
    /** True if screen from all, or false if screen from specific participants */
    screen_all?: boolean;
    /** List of participant/endpoint external reference ids to screen from */
    screen_from_external_reference_ids?: string[] | undefined;
}

export class UpdateAccountDetailsRequest implements IUpdateAccountDetailsRequest {
    first_name?: string | undefined;
    last_name?: string | undefined;
    current_username?: string | undefined;

    constructor(data?: IUpdateAccountDetailsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.current_username = _data['current_username'];
        }
    }

    static fromJS(data: any): UpdateAccountDetailsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountDetailsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['current_username'] = this.current_username;
        return data;
    }
}

export interface IUpdateAccountDetailsRequest {
    first_name?: string | undefined;
    last_name?: string | undefined;
    current_username?: string | undefined;
}

export class UpdateHearingInGroupRequest implements IUpdateHearingInGroupRequest {
    hearing_id?: string;
    scheduled_date_time?: Date;

    constructor(data?: IUpdateHearingInGroupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hearing_id = _data['hearing_id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateHearingInGroupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHearingInGroupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['hearing_id'] = this.hearing_id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateHearingInGroupRequest {
    hearing_id?: string;
    scheduled_date_time?: Date;
}

export class AllocationHearingsResponse implements IAllocationHearingsResponse {
    /** The hearing id */
    hearing_id?: string;
    /** The date and time of the hearing */
    scheduled_date_time?: Date;
    /** The duration of a hearing in minutes */
    duration?: number;
    /** The hearing case number */
    case_number?: string | undefined;
    /** The hearing case type */
    case_type?: string | undefined;
    /** The allocated CSO. Can be one of following:
<list type="bullet"><item>"Not Allocated"</item><item>"Not Required" (if venue is scottish or case type is generic)</item><item>The username of the allocated justice user</item></list> */
    allocated_cso?: string | undefined;
    /** True if the hearing is outside of the CSO's work hours. Null if the hearing has no allocated CSO */
    has_work_hours_clash?: boolean | undefined;
    has_non_availability_clash?: boolean | undefined;
    /** True if the allocated CSO has more than 3 concurrent hearings assigned. Null if the hearing has no allocated CSO */
    concurrent_hearings_count?: number | undefined;

    constructor(data?: IAllocationHearingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hearing_id = _data['hearing_id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.duration = _data['duration'];
            this.case_number = _data['case_number'];
            this.case_type = _data['case_type'];
            this.allocated_cso = _data['allocated_cso'];
            this.has_work_hours_clash = _data['has_work_hours_clash'];
            this.has_non_availability_clash = _data['has_non_availability_clash'];
            this.concurrent_hearings_count = _data['concurrent_hearings_count'];
        }
    }

    static fromJS(data: any): AllocationHearingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AllocationHearingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['hearing_id'] = this.hearing_id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['duration'] = this.duration;
        data['case_number'] = this.case_number;
        data['case_type'] = this.case_type;
        data['allocated_cso'] = this.allocated_cso;
        data['has_work_hours_clash'] = this.has_work_hours_clash;
        data['has_non_availability_clash'] = this.has_non_availability_clash;
        data['concurrent_hearings_count'] = this.concurrent_hearings_count;
        return data;
    }
}

export interface IAllocationHearingsResponse {
    /** The hearing id */
    hearing_id?: string;
    /** The date and time of the hearing */
    scheduled_date_time?: Date;
    /** The duration of a hearing in minutes */
    duration?: number;
    /** The hearing case number */
    case_number?: string | undefined;
    /** The hearing case type */
    case_type?: string | undefined;
    /** The allocated CSO. Can be one of following:
<list type="bullet"><item>"Not Allocated"</item><item>"Not Required" (if venue is scottish or case type is generic)</item><item>The username of the allocated justice user</item></list> */
    allocated_cso?: string | undefined;
    /** True if the hearing is outside of the CSO's work hours. Null if the hearing has no allocated CSO */
    has_work_hours_clash?: boolean | undefined;
    has_non_availability_clash?: boolean | undefined;
    /** True if the allocated CSO has more than 3 concurrent hearings assigned. Null if the hearing has no allocated CSO */
    concurrent_hearings_count?: number | undefined;
}

export class AppHealthStatusResponse implements IAppHealthStatusResponse {
    name?: string | undefined;
    state?: string | undefined;

    constructor(data?: IAppHealthStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data['name'];
            this.state = _data['state'];
        }
    }

    static fromJS(data: any): AppHealthStatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppHealthStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['name'] = this.name;
        data['state'] = this.state;
        return data;
    }
}

export interface IAppHealthStatusResponse {
    name?: string | undefined;
    state?: string | undefined;
}

/** Defines an available language supported for interpretation */
export class AvailableLanguageResponse implements IAvailableLanguageResponse {
    /** The short code for the language */
    code?: string | undefined;
    /** The plain text description of the language */
    description?: string | undefined;
    type?: InterprepretationType;

    constructor(data?: IAvailableLanguageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data['code'];
            this.description = _data['description'];
            this.type = _data['type'];
        }
    }

    static fromJS(data: any): AvailableLanguageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableLanguageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['code'] = this.code;
        data['description'] = this.description;
        data['type'] = this.type;
        return data;
    }
}

/** Defines an available language supported for interpretation */
export interface IAvailableLanguageResponse {
    /** The short code for the language */
    code?: string | undefined;
    /** The plain text description of the language */
    description?: string | undefined;
    type?: InterprepretationType;
}

export class AzureConfiguration implements IAzureConfiguration {
    /** The Azure Tenant Id */
    tenant_id?: string | undefined;
    /** The UI Client Id */
    client_id?: string | undefined;
    /** The UI Resource Id, can be used as an alternative id to ClientId for authentication */
    resource_id?: string | undefined;
    /** The Uri to redirect back to after a successful login */
    redirect_uri?: string | undefined;
    /** The Uri to redirect back to after a successful logout */
    post_logout_redirect_uri?: string | undefined;

    constructor(data?: IAzureConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant_id = _data['tenant_id'];
            this.client_id = _data['client_id'];
            this.resource_id = _data['resource_id'];
            this.redirect_uri = _data['redirect_uri'];
            this.post_logout_redirect_uri = _data['post_logout_redirect_uri'];
        }
    }

    static fromJS(data: any): AzureConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new AzureConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['tenant_id'] = this.tenant_id;
        data['client_id'] = this.client_id;
        data['resource_id'] = this.resource_id;
        data['redirect_uri'] = this.redirect_uri;
        data['post_logout_redirect_uri'] = this.post_logout_redirect_uri;
        return data;
    }
}

export interface IAzureConfiguration {
    /** The Azure Tenant Id */
    tenant_id?: string | undefined;
    /** The UI Client Id */
    client_id?: string | undefined;
    /** The UI Resource Id, can be used as an alternative id to ClientId for authentication */
    resource_id?: string | undefined;
    /** The Uri to redirect back to after a successful login */
    redirect_uri?: string | undefined;
    /** The Uri to redirect back to after a successful logout */
    post_logout_redirect_uri?: string | undefined;
}

export class BookingsByDateResponse implements IBookingsByDateResponse {
    scheduled_date?: Date;
    hearings?: BookingsHearingResponse[] | undefined;

    constructor(data?: IBookingsByDateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduled_date = _data['scheduled_date'] ? new Date(_data['scheduled_date'].toString()) : <any>undefined;
            if (Array.isArray(_data['hearings'])) {
                this.hearings = [] as any;
                for (let item of _data['hearings']) this.hearings!.push(BookingsHearingResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BookingsByDateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BookingsByDateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['scheduled_date'] = this.scheduled_date ? this.scheduled_date.toISOString() : <any>undefined;
        if (Array.isArray(this.hearings)) {
            data['hearings'] = [];
            for (let item of this.hearings) data['hearings'].push(item.toJSON());
        }
        return data;
    }
}

export interface IBookingsByDateResponse {
    scheduled_date?: Date;
    hearings?: BookingsHearingResponse[] | undefined;
}

export class BookingsHearingResponse implements IBookingsHearingResponse {
    hearing_id?: string;
    hearing_number?: string | undefined;
    hearing_name?: string | undefined;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type_name?: string | undefined;
    court_room?: string | undefined;
    court_address?: string | undefined;
    judge_name?: string | undefined;
    created_by?: string | undefined;
    created_date?: Date;
    last_edit_by?: string | undefined;
    last_edit_date?: Date | undefined;
    confirmed_by?: string | undefined;
    confirmed_date?: Date | undefined;
    hearing_date?: Date;
    status?: BookingStatus2;
    audio_recording_required?: boolean;
    cancel_reason?: string | undefined;
    group_id?: string | undefined;
    court_room_account?: string | undefined;
    allocated_to?: string | undefined;
    conference_supplier?: VideoSupplier;

    constructor(data?: IBookingsHearingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hearing_id = _data['hearing_id'];
            this.hearing_number = _data['hearing_number'];
            this.hearing_name = _data['hearing_name'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type_name = _data['case_type_name'];
            this.court_room = _data['court_room'];
            this.court_address = _data['court_address'];
            this.judge_name = _data['judge_name'];
            this.created_by = _data['created_by'];
            this.created_date = _data['created_date'] ? new Date(_data['created_date'].toString()) : <any>undefined;
            this.last_edit_by = _data['last_edit_by'];
            this.last_edit_date = _data['last_edit_date'] ? new Date(_data['last_edit_date'].toString()) : <any>undefined;
            this.confirmed_by = _data['confirmed_by'];
            this.confirmed_date = _data['confirmed_date'] ? new Date(_data['confirmed_date'].toString()) : <any>undefined;
            this.hearing_date = _data['hearing_date'] ? new Date(_data['hearing_date'].toString()) : <any>undefined;
            this.status = _data['status'];
            this.audio_recording_required = _data['audio_recording_required'];
            this.cancel_reason = _data['cancel_reason'];
            this.group_id = _data['group_id'];
            this.court_room_account = _data['court_room_account'];
            this.allocated_to = _data['allocated_to'];
            this.conference_supplier = _data['conference_supplier'];
        }
    }

    static fromJS(data: any): BookingsHearingResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BookingsHearingResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['hearing_id'] = this.hearing_id;
        data['hearing_number'] = this.hearing_number;
        data['hearing_name'] = this.hearing_name;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type_name'] = this.case_type_name;
        data['court_room'] = this.court_room;
        data['court_address'] = this.court_address;
        data['judge_name'] = this.judge_name;
        data['created_by'] = this.created_by;
        data['created_date'] = this.created_date ? this.created_date.toISOString() : <any>undefined;
        data['last_edit_by'] = this.last_edit_by;
        data['last_edit_date'] = this.last_edit_date ? this.last_edit_date.toISOString() : <any>undefined;
        data['confirmed_by'] = this.confirmed_by;
        data['confirmed_date'] = this.confirmed_date ? this.confirmed_date.toISOString() : <any>undefined;
        data['hearing_date'] = this.hearing_date ? this.hearing_date.toISOString() : <any>undefined;
        data['status'] = this.status;
        data['audio_recording_required'] = this.audio_recording_required;
        data['cancel_reason'] = this.cancel_reason;
        data['group_id'] = this.group_id;
        data['court_room_account'] = this.court_room_account;
        data['allocated_to'] = this.allocated_to;
        data['conference_supplier'] = this.conference_supplier;
        return data;
    }
}

export interface IBookingsHearingResponse {
    hearing_id?: string;
    hearing_number?: string | undefined;
    hearing_name?: string | undefined;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type_name?: string | undefined;
    court_room?: string | undefined;
    court_address?: string | undefined;
    judge_name?: string | undefined;
    created_by?: string | undefined;
    created_date?: Date;
    last_edit_by?: string | undefined;
    last_edit_date?: Date | undefined;
    confirmed_by?: string | undefined;
    confirmed_date?: Date | undefined;
    hearing_date?: Date;
    status?: BookingStatus2;
    audio_recording_required?: boolean;
    cancel_reason?: string | undefined;
    group_id?: string | undefined;
    court_room_account?: string | undefined;
    allocated_to?: string | undefined;
    conference_supplier?: VideoSupplier;
}

export class BookingsResponse implements IBookingsResponse {
    next_cursor?: string | undefined;
    limit?: number;
    prev_page_url?: string | undefined;
    next_page_url?: string | undefined;
    hearings?: BookingsByDateResponse[] | undefined;

    constructor(data?: IBookingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.next_cursor = _data['next_cursor'];
            this.limit = _data['limit'];
            this.prev_page_url = _data['prev_page_url'];
            this.next_page_url = _data['next_page_url'];
            if (Array.isArray(_data['hearings'])) {
                this.hearings = [] as any;
                for (let item of _data['hearings']) this.hearings!.push(BookingsByDateResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BookingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BookingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['next_cursor'] = this.next_cursor;
        data['limit'] = this.limit;
        data['prev_page_url'] = this.prev_page_url;
        data['next_page_url'] = this.next_page_url;
        if (Array.isArray(this.hearings)) {
            data['hearings'] = [];
            for (let item of this.hearings) data['hearings'].push(item.toJSON());
        }
        return data;
    }
}

export interface IBookingsResponse {
    next_cursor?: string | undefined;
    limit?: number;
    prev_page_url?: string | undefined;
    next_page_url?: string | undefined;
    hearings?: BookingsByDateResponse[] | undefined;
}

export class CaseResponse implements ICaseResponse {
    number?: string | undefined;
    name?: string | undefined;
    is_lead_case?: boolean;

    constructor(data?: ICaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data['number'];
            this.name = _data['name'];
            this.is_lead_case = _data['is_lead_case'];
        }
    }

    static fromJS(data: any): CaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['number'] = this.number;
        data['name'] = this.name;
        data['is_lead_case'] = this.is_lead_case;
        return data;
    }
}

export interface ICaseResponse {
    number?: string | undefined;
    name?: string | undefined;
    is_lead_case?: boolean;
}

/** Configuration to initialise the UI application */
export class ClientSettingsResponse implements IClientSettingsResponse {
    /** The Application Insights Connection String */
    connection_string?: string | undefined;
    /** The reform email */
    test_username_stem?: string | undefined;
    /** To join the conference phone number */
    conference_phone_number?: string | undefined;
    /** To join the conference phone number - welsh */
    conference_phone_number_welsh?: string | undefined;
    /** The Uri to video web url */
    video_web_url?: string | undefined;
    /** The LaunchDarkly Client ID */
    readonly launch_darkly_client_id?: string | undefined;
    reform_tenant_config?: AzureConfiguration;
    /** The url to the Dynatrace Real User Monitoring javascript script. */
    dynatrace_rum_link?: string | undefined;
    /** The Azure Tenant Id */
    tenant_id?: string | undefined;
    /** The UI Client Id */
    client_id?: string | undefined;
    /** The UI Resource Id, can be used as an alternative id to ClientId for authentication */
    resource_id?: string | undefined;
    /** The Uri to redirect back to after a successful login */
    redirect_uri?: string | undefined;
    /** The Uri to redirect back to after a successful logout */
    post_logout_redirect_uri?: string | undefined;

    constructor(data?: IClientSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connection_string = _data['connection_string'];
            this.test_username_stem = _data['test_username_stem'];
            this.conference_phone_number = _data['conference_phone_number'];
            this.conference_phone_number_welsh = _data['conference_phone_number_welsh'];
            this.video_web_url = _data['video_web_url'];
            (<any>this).launch_darkly_client_id = _data['launch_darkly_client_id'];
            this.reform_tenant_config = _data['reform_tenant_config']
                ? AzureConfiguration.fromJS(_data['reform_tenant_config'])
                : <any>undefined;
            this.dynatrace_rum_link = _data['dynatrace_rum_link'];
            this.tenant_id = _data['tenant_id'];
            this.client_id = _data['client_id'];
            this.resource_id = _data['resource_id'];
            this.redirect_uri = _data['redirect_uri'];
            this.post_logout_redirect_uri = _data['post_logout_redirect_uri'];
        }
    }

    static fromJS(data: any): ClientSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['connection_string'] = this.connection_string;
        data['test_username_stem'] = this.test_username_stem;
        data['conference_phone_number'] = this.conference_phone_number;
        data['conference_phone_number_welsh'] = this.conference_phone_number_welsh;
        data['video_web_url'] = this.video_web_url;
        data['launch_darkly_client_id'] = this.launch_darkly_client_id;
        data['reform_tenant_config'] = this.reform_tenant_config ? this.reform_tenant_config.toJSON() : <any>undefined;
        data['dynatrace_rum_link'] = this.dynatrace_rum_link;
        data['tenant_id'] = this.tenant_id;
        data['client_id'] = this.client_id;
        data['resource_id'] = this.resource_id;
        data['redirect_uri'] = this.redirect_uri;
        data['post_logout_redirect_uri'] = this.post_logout_redirect_uri;
        return data;
    }
}

/** Configuration to initialise the UI application */
export interface IClientSettingsResponse {
    /** The Application Insights Connection String */
    connection_string?: string | undefined;
    /** The reform email */
    test_username_stem?: string | undefined;
    /** To join the conference phone number */
    conference_phone_number?: string | undefined;
    /** To join the conference phone number - welsh */
    conference_phone_number_welsh?: string | undefined;
    /** The Uri to video web url */
    video_web_url?: string | undefined;
    /** The LaunchDarkly Client ID */
    launch_darkly_client_id?: string | undefined;
    reform_tenant_config?: AzureConfiguration;
    /** The url to the Dynatrace Real User Monitoring javascript script. */
    dynatrace_rum_link?: string | undefined;
    /** The Azure Tenant Id */
    tenant_id?: string | undefined;
    /** The UI Client Id */
    client_id?: string | undefined;
    /** The UI Resource Id, can be used as an alternative id to ClientId for authentication */
    resource_id?: string | undefined;
    /** The Uri to redirect back to after a successful login */
    redirect_uri?: string | undefined;
    /** The Uri to redirect back to after a successful logout */
    post_logout_redirect_uri?: string | undefined;
}

export class DateForUnallocatedHearings implements IDateForUnallocatedHearings {
    count?: number;
    date_start?: Date;
    date_end?: Date | undefined;

    constructor(data?: IDateForUnallocatedHearings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data['count'];
            this.date_start = _data['date_start'] ? new Date(_data['date_start'].toString()) : <any>undefined;
            this.date_end = _data['date_end'] ? new Date(_data['date_end'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateForUnallocatedHearings {
        data = typeof data === 'object' ? data : {};
        let result = new DateForUnallocatedHearings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['count'] = this.count;
        data['date_start'] = this.date_start ? this.date_start.toISOString() : <any>undefined;
        data['date_end'] = this.date_end ? this.date_end.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDateForUnallocatedHearings {
    count?: number;
    date_start?: Date;
    date_end?: Date | undefined;
}

export class EndpointResponse implements IEndpointResponse {
    id?: string;
    external_reference_id?: string | undefined;
    measures_external_id?: string | undefined;
    display_name?: string | undefined;
    sip?: string | undefined;
    pin?: string | undefined;
    defence_advocate_id?: string | undefined;
    interpreter_language?: AvailableLanguageResponse;
    screening_requirement?: ScreeningResponse;

    constructor(data?: IEndpointResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.external_reference_id = _data['external_reference_id'];
            this.measures_external_id = _data['measures_external_id'];
            this.display_name = _data['display_name'];
            this.sip = _data['sip'];
            this.pin = _data['pin'];
            this.defence_advocate_id = _data['defence_advocate_id'];
            this.interpreter_language = _data['interpreter_language']
                ? AvailableLanguageResponse.fromJS(_data['interpreter_language'])
                : <any>undefined;
            this.screening_requirement = _data['screening_requirement']
                ? ScreeningResponse.fromJS(_data['screening_requirement'])
                : <any>undefined;
        }
    }

    static fromJS(data: any): EndpointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EndpointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['external_reference_id'] = this.external_reference_id;
        data['measures_external_id'] = this.measures_external_id;
        data['display_name'] = this.display_name;
        data['sip'] = this.sip;
        data['pin'] = this.pin;
        data['defence_advocate_id'] = this.defence_advocate_id;
        data['interpreter_language'] = this.interpreter_language ? this.interpreter_language.toJSON() : <any>undefined;
        data['screening_requirement'] = this.screening_requirement ? this.screening_requirement.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEndpointResponse {
    id?: string;
    external_reference_id?: string | undefined;
    measures_external_id?: string | undefined;
    display_name?: string | undefined;
    sip?: string | undefined;
    pin?: string | undefined;
    defence_advocate_id?: string | undefined;
    interpreter_language?: AvailableLanguageResponse;
    screening_requirement?: ScreeningResponse;
}

export class HearingDetailsResponse implements IHearingDetailsResponse {
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    /** V2 only */
    hearing_venue_code?: string | undefined;
    /** V2 only */
    service_id?: string | undefined;
    /** V2 only */
    hearing_type_code?: string | undefined;
    cases?: CaseResponse[] | undefined;
    participants?: ParticipantResponse[] | undefined;
    judiciary_participants?: JudiciaryParticipantResponse[] | undefined;
    hearing_room_name?: string | undefined;
    other_information?: string | undefined;
    created_date?: Date;
    created_by?: string | undefined;
    updated_by?: string | undefined;
    updated_date?: Date;
    confirmed_by?: string | undefined;
    confirmed_date?: Date | undefined;
    status?: BookingStatus;
    audio_recording_required?: boolean;
    cancel_reason?: string | undefined;
    endpoints?: EndpointResponse[] | undefined;
    group_id?: string | undefined;
    /** Scheduled datetime of the last day of the multi day hearing, if applicable */
    multi_day_hearing_last_day_scheduled_date_time?: Date | undefined;
    hearings_in_group?: HearingDetailsResponse[] | undefined;
    conference_supplier?: VideoSupplier;
    /** Username of the CSO allocated to the hearing, if applicable */
    allocated_to_username?: string | undefined;

    constructor(data?: IHearingDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.hearing_venue_code = _data['hearing_venue_code'];
            this.service_id = _data['service_id'];
            this.hearing_type_code = _data['hearing_type_code'];
            if (Array.isArray(_data['cases'])) {
                this.cases = [] as any;
                for (let item of _data['cases']) this.cases!.push(CaseResponse.fromJS(item));
            }
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantResponse.fromJS(item));
            }
            if (Array.isArray(_data['judiciary_participants'])) {
                this.judiciary_participants = [] as any;
                for (let item of _data['judiciary_participants'])
                    this.judiciary_participants!.push(JudiciaryParticipantResponse.fromJS(item));
            }
            this.hearing_room_name = _data['hearing_room_name'];
            this.other_information = _data['other_information'];
            this.created_date = _data['created_date'] ? new Date(_data['created_date'].toString()) : <any>undefined;
            this.created_by = _data['created_by'];
            this.updated_by = _data['updated_by'];
            this.updated_date = _data['updated_date'] ? new Date(_data['updated_date'].toString()) : <any>undefined;
            this.confirmed_by = _data['confirmed_by'];
            this.confirmed_date = _data['confirmed_date'] ? new Date(_data['confirmed_date'].toString()) : <any>undefined;
            this.status = _data['status'];
            this.audio_recording_required = _data['audio_recording_required'];
            this.cancel_reason = _data['cancel_reason'];
            if (Array.isArray(_data['endpoints'])) {
                this.endpoints = [] as any;
                for (let item of _data['endpoints']) this.endpoints!.push(EndpointResponse.fromJS(item));
            }
            this.group_id = _data['group_id'];
            this.multi_day_hearing_last_day_scheduled_date_time = _data['multi_day_hearing_last_day_scheduled_date_time']
                ? new Date(_data['multi_day_hearing_last_day_scheduled_date_time'].toString())
                : <any>undefined;
            if (Array.isArray(_data['hearings_in_group'])) {
                this.hearings_in_group = [] as any;
                for (let item of _data['hearings_in_group']) this.hearings_in_group!.push(HearingDetailsResponse.fromJS(item));
            }
            this.conference_supplier = _data['conference_supplier'];
            this.allocated_to_username = _data['allocated_to_username'];
        }
    }

    static fromJS(data: any): HearingDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['hearing_venue_code'] = this.hearing_venue_code;
        data['service_id'] = this.service_id;
        data['hearing_type_code'] = this.hearing_type_code;
        if (Array.isArray(this.cases)) {
            data['cases'] = [];
            for (let item of this.cases) data['cases'].push(item.toJSON());
        }
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        if (Array.isArray(this.judiciary_participants)) {
            data['judiciary_participants'] = [];
            for (let item of this.judiciary_participants) data['judiciary_participants'].push(item.toJSON());
        }
        data['hearing_room_name'] = this.hearing_room_name;
        data['other_information'] = this.other_information;
        data['created_date'] = this.created_date ? this.created_date.toISOString() : <any>undefined;
        data['created_by'] = this.created_by;
        data['updated_by'] = this.updated_by;
        data['updated_date'] = this.updated_date ? this.updated_date.toISOString() : <any>undefined;
        data['confirmed_by'] = this.confirmed_by;
        data['confirmed_date'] = this.confirmed_date ? this.confirmed_date.toISOString() : <any>undefined;
        data['status'] = this.status;
        data['audio_recording_required'] = this.audio_recording_required;
        data['cancel_reason'] = this.cancel_reason;
        if (Array.isArray(this.endpoints)) {
            data['endpoints'] = [];
            for (let item of this.endpoints) data['endpoints'].push(item.toJSON());
        }
        data['group_id'] = this.group_id;
        data['multi_day_hearing_last_day_scheduled_date_time'] = this.multi_day_hearing_last_day_scheduled_date_time
            ? this.multi_day_hearing_last_day_scheduled_date_time.toISOString()
            : <any>undefined;
        if (Array.isArray(this.hearings_in_group)) {
            data['hearings_in_group'] = [];
            for (let item of this.hearings_in_group) data['hearings_in_group'].push(item.toJSON());
        }
        data['conference_supplier'] = this.conference_supplier;
        data['allocated_to_username'] = this.allocated_to_username;
        return data;
    }
}

export interface IHearingDetailsResponse {
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    /** V2 only */
    hearing_venue_code?: string | undefined;
    /** V2 only */
    service_id?: string | undefined;
    /** V2 only */
    hearing_type_code?: string | undefined;
    cases?: CaseResponse[] | undefined;
    participants?: ParticipantResponse[] | undefined;
    judiciary_participants?: JudiciaryParticipantResponse[] | undefined;
    hearing_room_name?: string | undefined;
    other_information?: string | undefined;
    created_date?: Date;
    created_by?: string | undefined;
    updated_by?: string | undefined;
    updated_date?: Date;
    confirmed_by?: string | undefined;
    confirmed_date?: Date | undefined;
    status?: BookingStatus;
    audio_recording_required?: boolean;
    cancel_reason?: string | undefined;
    endpoints?: EndpointResponse[] | undefined;
    group_id?: string | undefined;
    /** Scheduled datetime of the last day of the multi day hearing, if applicable */
    multi_day_hearing_last_day_scheduled_date_time?: Date | undefined;
    hearings_in_group?: HearingDetailsResponse[] | undefined;
    conference_supplier?: VideoSupplier;
    /** Username of the CSO allocated to the hearing, if applicable */
    allocated_to_username?: string | undefined;
}

export class HearingRoleResponse implements IHearingRoleResponse {
    name?: string | undefined;
    user_role?: string | undefined;
    code?: string | undefined;

    constructor(data?: IHearingRoleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data['name'];
            this.user_role = _data['user_role'];
            this.code = _data['code'];
        }
    }

    static fromJS(data: any): HearingRoleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingRoleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['name'] = this.name;
        data['user_role'] = this.user_role;
        data['code'] = this.code;
        return data;
    }
}

export interface IHearingRoleResponse {
    name?: string | undefined;
    user_role?: string | undefined;
    code?: string | undefined;
}

/** Defines a type of hearing based on case */
export class HearingTypeResponse implements IHearingTypeResponse {
    /** Which case type it belongs to */
    group?: string | undefined;
    /** Unique identifier for this type of hearing */
    id?: number | undefined;
    /** The service id for the type */
    service_id?: string | undefined;

    constructor(data?: IHearingTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data['group'];
            this.id = _data['id'];
            this.service_id = _data['service_id'];
        }
    }

    static fromJS(data: any): HearingTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['group'] = this.group;
        data['id'] = this.id;
        data['service_id'] = this.service_id;
        return data;
    }
}

/** Defines a type of hearing based on case */
export interface IHearingTypeResponse {
    /** Which case type it belongs to */
    group?: string | undefined;
    /** Unique identifier for this type of hearing */
    id?: number | undefined;
    /** The service id for the type */
    service_id?: string | undefined;
}

/** A judge existing in the system */
export class JudgeResponse implements IJudgeResponse {
    /** Judge first name */
    first_name?: string | undefined;
    /** Judge last name */
    last_name?: string | undefined;
    /** Judge display name as in the identity system */
    display_name?: string | undefined;
    /** Judge username/email */
    email?: string | undefined;
    /** Judge contact email */
    contact_email?: string | undefined;
    account_type?: JudgeAccountType;

    constructor(data?: IJudgeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.email = _data['email'];
            this.contact_email = _data['contact_email'];
            this.account_type = _data['account_type'];
        }
    }

    static fromJS(data: any): JudgeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JudgeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['email'] = this.email;
        data['contact_email'] = this.contact_email;
        data['account_type'] = this.account_type;
        return data;
    }
}

/** A judge existing in the system */
export interface IJudgeResponse {
    /** Judge first name */
    first_name?: string | undefined;
    /** Judge last name */
    last_name?: string | undefined;
    /** Judge display name as in the identity system */
    display_name?: string | undefined;
    /** Judge username/email */
    email?: string | undefined;
    /** Judge contact email */
    contact_email?: string | undefined;
    account_type?: JudgeAccountType;
}

export class JudiciaryParticipantResponse implements IJudiciaryParticipantResponse {
    /** Judiciary person's Title. */
    title?: string | undefined;
    /** Judiciary person's first name. */
    first_name?: string | undefined;
    /** Judiciary person's last name. */
    last_name?: string | undefined;
    /** Judiciary person's full name. */
    full_name?: string | undefined;
    /** Judiciary person's contact email */
    email?: string | undefined;
    /** Judiciary person's work phone */
    work_phone?: string | undefined;
    /** The Judiciary person's unique personal code */
    personal_code?: string | undefined;
    /** The Judiciary person's role code (Judge or Panel Member) */
    role_code?: string | undefined;
    /** The judiciary person's display name */
    display_name?: string | undefined;
    /** Is a generic account, with custom contact details */
    is_generic?: boolean;
    /** Is an optional contact number for generic accounts */
    optional_contact_email?: string | undefined;
    /** Is an optional contact number for generic accounts */
    optional_contact_telephone?: string | undefined;
    interpreter_language?: AvailableLanguageResponse;

    constructor(data?: IJudiciaryParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data['title'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.full_name = _data['full_name'];
            this.email = _data['email'];
            this.work_phone = _data['work_phone'];
            this.personal_code = _data['personal_code'];
            this.role_code = _data['role_code'];
            this.display_name = _data['display_name'];
            this.is_generic = _data['is_generic'];
            this.optional_contact_email = _data['optional_contact_email'];
            this.optional_contact_telephone = _data['optional_contact_telephone'];
            this.interpreter_language = _data['interpreter_language']
                ? AvailableLanguageResponse.fromJS(_data['interpreter_language'])
                : <any>undefined;
        }
    }

    static fromJS(data: any): JudiciaryParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JudiciaryParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['title'] = this.title;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['full_name'] = this.full_name;
        data['email'] = this.email;
        data['work_phone'] = this.work_phone;
        data['personal_code'] = this.personal_code;
        data['role_code'] = this.role_code;
        data['display_name'] = this.display_name;
        data['is_generic'] = this.is_generic;
        data['optional_contact_email'] = this.optional_contact_email;
        data['optional_contact_telephone'] = this.optional_contact_telephone;
        data['interpreter_language'] = this.interpreter_language ? this.interpreter_language.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJudiciaryParticipantResponse {
    /** Judiciary person's Title. */
    title?: string | undefined;
    /** Judiciary person's first name. */
    first_name?: string | undefined;
    /** Judiciary person's last name. */
    last_name?: string | undefined;
    /** Judiciary person's full name. */
    full_name?: string | undefined;
    /** Judiciary person's contact email */
    email?: string | undefined;
    /** Judiciary person's work phone */
    work_phone?: string | undefined;
    /** The Judiciary person's unique personal code */
    personal_code?: string | undefined;
    /** The Judiciary person's role code (Judge or Panel Member) */
    role_code?: string | undefined;
    /** The judiciary person's display name */
    display_name?: string | undefined;
    /** Is a generic account, with custom contact details */
    is_generic?: boolean;
    /** Is an optional contact number for generic accounts */
    optional_contact_email?: string | undefined;
    /** Is an optional contact number for generic accounts */
    optional_contact_telephone?: string | undefined;
    interpreter_language?: AvailableLanguageResponse;
}

export class JudiciaryPerson implements IJudiciaryPerson {
    /** Judiciary person's Title. */
    title?: string | undefined;
    /** Judiciary person's first name. */
    first_name?: string | undefined;
    /** Judiciary person's last name. */
    last_name?: string | undefined;
    /** Judiciary person's full name. */
    full_name?: string | undefined;
    /** Judiciary person's contact email */
    email?: string | undefined;
    /** Judiciary person's work phone */
    work_phone?: string | undefined;
    /** The Judiciary person's unique personal code */
    personal_code?: string | undefined;
    /** Is a generic account */
    is_generic?: boolean;

    constructor(data?: IJudiciaryPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data['title'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.full_name = _data['full_name'];
            this.email = _data['email'];
            this.work_phone = _data['work_phone'];
            this.personal_code = _data['personal_code'];
            this.is_generic = _data['is_generic'];
        }
    }

    static fromJS(data: any): JudiciaryPerson {
        data = typeof data === 'object' ? data : {};
        let result = new JudiciaryPerson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['title'] = this.title;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['full_name'] = this.full_name;
        data['email'] = this.email;
        data['work_phone'] = this.work_phone;
        data['personal_code'] = this.personal_code;
        data['is_generic'] = this.is_generic;
        return data;
    }
}

export interface IJudiciaryPerson {
    /** Judiciary person's Title. */
    title?: string | undefined;
    /** Judiciary person's first name. */
    first_name?: string | undefined;
    /** Judiciary person's last name. */
    last_name?: string | undefined;
    /** Judiciary person's full name. */
    full_name?: string | undefined;
    /** Judiciary person's contact email */
    email?: string | undefined;
    /** Judiciary person's work phone */
    work_phone?: string | undefined;
    /** The Judiciary person's unique personal code */
    personal_code?: string | undefined;
    /** Is a generic account */
    is_generic?: boolean;
}

export class LinkedParticipantResponse implements ILinkedParticipantResponse {
    linked_id?: string;
    type?: LinkedParticipantType;

    constructor(data?: ILinkedParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linked_id = _data['linked_id'];
            this.type = _data['type'];
        }
    }

    static fromJS(data: any): LinkedParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['linked_id'] = this.linked_id;
        data['type'] = this.type;
        return data;
    }
}

export interface ILinkedParticipantResponse {
    linked_id?: string;
    type?: LinkedParticipantType;
}

export class ParticipantResponse implements IParticipantResponse {
    id?: string;
    external_reference_id?: string | undefined;
    measures_external_id?: string | undefined;
    display_name?: string | undefined;
    hearing_role_name?: string | undefined;
    hearing_role_code?: string | undefined;
    user_role_name?: string | undefined;
    title?: string | undefined;
    first_name?: string | undefined;
    middle_names?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    telephone_number?: string | undefined;
    username?: string | undefined;
    organisation?: string | undefined;
    representee?: string | undefined;
    interpreter_language?: AvailableLanguageResponse;
    screening_requirement?: ScreeningResponse;
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.external_reference_id = _data['external_reference_id'];
            this.measures_external_id = _data['measures_external_id'];
            this.display_name = _data['display_name'];
            this.hearing_role_name = _data['hearing_role_name'];
            this.hearing_role_code = _data['hearing_role_code'];
            this.user_role_name = _data['user_role_name'];
            this.title = _data['title'];
            this.first_name = _data['first_name'];
            this.middle_names = _data['middle_names'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.telephone_number = _data['telephone_number'];
            this.username = _data['username'];
            this.organisation = _data['organisation'];
            this.representee = _data['representee'];
            this.interpreter_language = _data['interpreter_language']
                ? AvailableLanguageResponse.fromJS(_data['interpreter_language'])
                : <any>undefined;
            this.screening_requirement = _data['screening_requirement']
                ? ScreeningResponse.fromJS(_data['screening_requirement'])
                : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['external_reference_id'] = this.external_reference_id;
        data['measures_external_id'] = this.measures_external_id;
        data['display_name'] = this.display_name;
        data['hearing_role_name'] = this.hearing_role_name;
        data['hearing_role_code'] = this.hearing_role_code;
        data['user_role_name'] = this.user_role_name;
        data['title'] = this.title;
        data['first_name'] = this.first_name;
        data['middle_names'] = this.middle_names;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['telephone_number'] = this.telephone_number;
        data['username'] = this.username;
        data['organisation'] = this.organisation;
        data['representee'] = this.representee;
        data['interpreter_language'] = this.interpreter_language ? this.interpreter_language.toJSON() : <any>undefined;
        data['screening_requirement'] = this.screening_requirement ? this.screening_requirement.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IParticipantResponse {
    id?: string;
    external_reference_id?: string | undefined;
    measures_external_id?: string | undefined;
    display_name?: string | undefined;
    hearing_role_name?: string | undefined;
    hearing_role_code?: string | undefined;
    user_role_name?: string | undefined;
    title?: string | undefined;
    first_name?: string | undefined;
    middle_names?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    telephone_number?: string | undefined;
    username?: string | undefined;
    organisation?: string | undefined;
    representee?: string | undefined;
    interpreter_language?: AvailableLanguageResponse;
    screening_requirement?: ScreeningResponse;
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

export class ScreeningResponse implements IScreeningResponse {
    type?: ScreeningType;
    /** A list of participant/endpoint external ref ids to be protected from */
    protect_from?: string[] | undefined;

    constructor(data?: IScreeningResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data['type'];
            if (Array.isArray(_data['protect_from'])) {
                this.protect_from = [] as any;
                for (let item of _data['protect_from']) this.protect_from!.push(item);
            }
        }
    }

    static fromJS(data: any): ScreeningResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ScreeningResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['type'] = this.type;
        if (Array.isArray(this.protect_from)) {
            data['protect_from'] = [];
            for (let item of this.protect_from) data['protect_from'].push(item);
        }
        return data;
    }
}

export interface IScreeningResponse {
    type?: ScreeningType;
    /** A list of participant/endpoint external ref ids to be protected from */
    protect_from?: string[] | undefined;
}

export class UnallocatedHearingsForVhoResponse implements IUnallocatedHearingsForVhoResponse {
    today?: DateForUnallocatedHearings;
    tomorrow?: DateForUnallocatedHearings;
    next7_days?: DateForUnallocatedHearings;
    next30_days?: DateForUnallocatedHearings;

    constructor(data?: IUnallocatedHearingsForVhoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.today = _data['today'] ? DateForUnallocatedHearings.fromJS(_data['today']) : <any>undefined;
            this.tomorrow = _data['tomorrow'] ? DateForUnallocatedHearings.fromJS(_data['tomorrow']) : <any>undefined;
            this.next7_days = _data['next7_days'] ? DateForUnallocatedHearings.fromJS(_data['next7_days']) : <any>undefined;
            this.next30_days = _data['next30_days'] ? DateForUnallocatedHearings.fromJS(_data['next30_days']) : <any>undefined;
        }
    }

    static fromJS(data: any): UnallocatedHearingsForVhoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnallocatedHearingsForVhoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['today'] = this.today ? this.today.toJSON() : <any>undefined;
        data['tomorrow'] = this.tomorrow ? this.tomorrow.toJSON() : <any>undefined;
        data['next7_days'] = this.next7_days ? this.next7_days.toJSON() : <any>undefined;
        data['next30_days'] = this.next30_days ? this.next30_days.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUnallocatedHearingsForVhoResponse {
    today?: DateForUnallocatedHearings;
    tomorrow?: DateForUnallocatedHearings;
    next7_days?: DateForUnallocatedHearings;
    next30_days?: DateForUnallocatedHearings;
}

export class UnexpectedErrorResponse implements IUnexpectedErrorResponse {
    error_message?: string | undefined;

    constructor(data?: IUnexpectedErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error_message = _data['error_message'];
        }
    }

    static fromJS(data: any): UnexpectedErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnexpectedErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['error_message'] = this.error_message;
        return data;
    }
}

export interface IUnexpectedErrorResponse {
    error_message?: string | undefined;
}

export class UserProfileResponse implements IUserProfileResponse {
    is_vh_officer_administrator_role?: boolean;
    is_vh_team_leader?: boolean;
    is_case_administrator?: boolean;

    constructor(data?: IUserProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.is_vh_officer_administrator_role = _data['is_vh_officer_administrator_role'];
            this.is_vh_team_leader = _data['is_vh_team_leader'];
            this.is_case_administrator = _data['is_case_administrator'];
        }
    }

    static fromJS(data: any): UserProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['is_vh_officer_administrator_role'] = this.is_vh_officer_administrator_role;
        data['is_vh_team_leader'] = this.is_vh_team_leader;
        data['is_case_administrator'] = this.is_case_administrator;
        return data;
    }
}

export interface IUserProfileResponse {
    is_vh_officer_administrator_role?: boolean;
    is_vh_team_leader?: boolean;
    is_case_administrator?: boolean;
}

export class CvpForAudioFileResponse implements ICvpForAudioFileResponse {
    file_name?: string | undefined;
    sas_token_uri?: string | undefined;

    constructor(data?: ICvpForAudioFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file_name = _data['file_name'];
            this.sas_token_uri = _data['sas_token_uri'];
        }
    }

    static fromJS(data: any): CvpForAudioFileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CvpForAudioFileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['file_name'] = this.file_name;
        data['sas_token_uri'] = this.sas_token_uri;
        return data;
    }
}

export interface ICvpForAudioFileResponse {
    file_name?: string | undefined;
    sas_token_uri?: string | undefined;
}

/** Case request */
export class EditCaseRequest implements IEditCaseRequest {
    /** The case number */
    number?: string | undefined;
    /** The case name */
    name?: string | undefined;

    constructor(data?: IEditCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data['number'];
            this.name = _data['name'];
        }
    }

    static fromJS(data: any): EditCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['number'] = this.number;
        data['name'] = this.name;
        return data;
    }
}

/** Case request */
export interface IEditCaseRequest {
    /** The case number */
    number?: string | undefined;
    /** The case name */
    name?: string | undefined;
}

export class EditEndpointRequest implements IEditEndpointRequest {
    /** Endpoint Id. */
    id?: string | undefined;
    /** The external reference id for the participant */
    external_reference_id?: string | undefined;
    /** The display name for the endpoint */
    display_name?: string | undefined;
    /** The username of the participant */
    defence_advocate_contact_email?: string | undefined;
    /** The code for the endpoint's interpreter language, if applicable */
    interpreter_language_code?: string | undefined;
    screening_requirements?: SpecialMeasureScreeningRequest;

    constructor(data?: IEditEndpointRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.external_reference_id = _data['external_reference_id'];
            this.display_name = _data['display_name'];
            this.defence_advocate_contact_email = _data['defence_advocate_contact_email'];
            this.interpreter_language_code = _data['interpreter_language_code'];
            this.screening_requirements = _data['screening_requirements']
                ? SpecialMeasureScreeningRequest.fromJS(_data['screening_requirements'])
                : <any>undefined;
        }
    }

    static fromJS(data: any): EditEndpointRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditEndpointRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['external_reference_id'] = this.external_reference_id;
        data['display_name'] = this.display_name;
        data['defence_advocate_contact_email'] = this.defence_advocate_contact_email;
        data['interpreter_language_code'] = this.interpreter_language_code;
        data['screening_requirements'] = this.screening_requirements ? this.screening_requirements.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEditEndpointRequest {
    /** Endpoint Id. */
    id?: string | undefined;
    /** The external reference id for the participant */
    external_reference_id?: string | undefined;
    /** The display name for the endpoint */
    display_name?: string | undefined;
    /** The username of the participant */
    defence_advocate_contact_email?: string | undefined;
    /** The code for the endpoint's interpreter language, if applicable */
    interpreter_language_code?: string | undefined;
    screening_requirements?: SpecialMeasureScreeningRequest;
}

/** Request for updating an existing hearing */
export class EditHearingRequest implements IEditHearingRequest {
    /** The date and time for a hearing */
    scheduled_date_time?: Date;
    /** The duration of a hearing (number of minutes) */
    scheduled_duration?: number;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** The code of the hearing venue */
    hearing_venue_code?: string | undefined;
    /** The hearing room name at the hearing venue */
    hearing_room_name?: string | undefined;
    case?: EditCaseRequest;
    /** List of participants in hearing */
    participants?: EditParticipantRequest[] | undefined;
    /** List of judiciary participants in hearing */
    judiciary_participants?: JudiciaryParticipantRequest[] | undefined;
    /** Any other information about the hearing */
    other_information?: string | undefined;
    /** Gets or sets audio recording required flag */
    audio_recording_required?: boolean;
    /** List of endpoints for the hearing */
    endpoints?: EditEndpointRequest[] | undefined;

    constructor(data?: IEditHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.hearing_venue_code = _data['hearing_venue_code'];
            this.hearing_room_name = _data['hearing_room_name'];
            this.case = _data['case'] ? EditCaseRequest.fromJS(_data['case']) : <any>undefined;
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(EditParticipantRequest.fromJS(item));
            }
            if (Array.isArray(_data['judiciary_participants'])) {
                this.judiciary_participants = [] as any;
                for (let item of _data['judiciary_participants'])
                    this.judiciary_participants!.push(JudiciaryParticipantRequest.fromJS(item));
            }
            this.other_information = _data['other_information'];
            this.audio_recording_required = _data['audio_recording_required'];
            if (Array.isArray(_data['endpoints'])) {
                this.endpoints = [] as any;
                for (let item of _data['endpoints']) this.endpoints!.push(EditEndpointRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['hearing_venue_code'] = this.hearing_venue_code;
        data['hearing_room_name'] = this.hearing_room_name;
        data['case'] = this.case ? this.case.toJSON() : <any>undefined;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        if (Array.isArray(this.judiciary_participants)) {
            data['judiciary_participants'] = [];
            for (let item of this.judiciary_participants) data['judiciary_participants'].push(item.toJSON());
        }
        data['other_information'] = this.other_information;
        data['audio_recording_required'] = this.audio_recording_required;
        if (Array.isArray(this.endpoints)) {
            data['endpoints'] = [];
            for (let item of this.endpoints) data['endpoints'].push(item.toJSON());
        }
        return data;
    }
}

/** Request for updating an existing hearing */
export interface IEditHearingRequest {
    /** The date and time for a hearing */
    scheduled_date_time?: Date;
    /** The duration of a hearing (number of minutes) */
    scheduled_duration?: number;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** The code of the hearing venue */
    hearing_venue_code?: string | undefined;
    /** The hearing room name at the hearing venue */
    hearing_room_name?: string | undefined;
    case?: EditCaseRequest;
    /** List of participants in hearing */
    participants?: EditParticipantRequest[] | undefined;
    /** List of judiciary participants in hearing */
    judiciary_participants?: JudiciaryParticipantRequest[] | undefined;
    /** Any other information about the hearing */
    other_information?: string | undefined;
    /** Gets or sets audio recording required flag */
    audio_recording_required?: boolean;
    /** List of endpoints for the hearing */
    endpoints?: EditEndpointRequest[] | undefined;
}

/** Participant request */
export class EditParticipantRequest implements IEditParticipantRequest {
    /** Participant Id. */
    id?: string | undefined;
    /** The external reference id for the participant */
    external_reference_id?: string | undefined;
    /** Participant Title. */
    title?: string | undefined;
    /** Participant first name. */
    first_name?: string | undefined;
    /** Participant middle name. */
    middle_names?: string | undefined;
    /** Participant last name. */
    last_name?: string | undefined;
    /** Participant Contact Email */
    contact_email?: string | undefined;
    /** Participant Telephone number */
    telephone_number?: string | undefined;
    /** Participant Display Name */
    display_name?: string | undefined;
    /** The name of the participant's hearing role */
    hearing_role_name?: string | undefined;
    /** The code of the participant's hearing role */
    hearing_role_code?: string | undefined;
    /** The representee of a representative */
    representee?: string | undefined;
    /** Organisation name */
    organisation_name?: string | undefined;
    /** The code for the participant's interpreter language, if applicable */
    interpreter_language_code?: string | undefined;
    screening_requirements?: SpecialMeasureScreeningRequest;
    /** List of linked participants */
    linked_participants?: LinkedParticipant[] | undefined;

    constructor(data?: IEditParticipantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.external_reference_id = _data['external_reference_id'];
            this.title = _data['title'];
            this.first_name = _data['first_name'];
            this.middle_names = _data['middle_names'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.telephone_number = _data['telephone_number'];
            this.display_name = _data['display_name'];
            this.hearing_role_name = _data['hearing_role_name'];
            this.hearing_role_code = _data['hearing_role_code'];
            this.representee = _data['representee'];
            this.organisation_name = _data['organisation_name'];
            this.interpreter_language_code = _data['interpreter_language_code'];
            this.screening_requirements = _data['screening_requirements']
                ? SpecialMeasureScreeningRequest.fromJS(_data['screening_requirements'])
                : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditParticipantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditParticipantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['external_reference_id'] = this.external_reference_id;
        data['title'] = this.title;
        data['first_name'] = this.first_name;
        data['middle_names'] = this.middle_names;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['telephone_number'] = this.telephone_number;
        data['display_name'] = this.display_name;
        data['hearing_role_name'] = this.hearing_role_name;
        data['hearing_role_code'] = this.hearing_role_code;
        data['representee'] = this.representee;
        data['organisation_name'] = this.organisation_name;
        data['interpreter_language_code'] = this.interpreter_language_code;
        data['screening_requirements'] = this.screening_requirements ? this.screening_requirements.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

/** Participant request */
export interface IEditParticipantRequest {
    /** Participant Id. */
    id?: string | undefined;
    /** The external reference id for the participant */
    external_reference_id?: string | undefined;
    /** Participant Title. */
    title?: string | undefined;
    /** Participant first name. */
    first_name?: string | undefined;
    /** Participant middle name. */
    middle_names?: string | undefined;
    /** Participant last name. */
    last_name?: string | undefined;
    /** Participant Contact Email */
    contact_email?: string | undefined;
    /** Participant Telephone number */
    telephone_number?: string | undefined;
    /** Participant Display Name */
    display_name?: string | undefined;
    /** The name of the participant's hearing role */
    hearing_role_name?: string | undefined;
    /** The code of the participant's hearing role */
    hearing_role_code?: string | undefined;
    /** The representee of a representative */
    representee?: string | undefined;
    /** Organisation name */
    organisation_name?: string | undefined;
    /** The code for the participant's interpreter language, if applicable */
    interpreter_language_code?: string | undefined;
    screening_requirements?: SpecialMeasureScreeningRequest;
    /** List of linked participants */
    linked_participants?: LinkedParticipant[] | undefined;
}

export class HearingAudioRecordingResponse implements IHearingAudioRecordingResponse {
    audio_file_links?: string[] | undefined;

    constructor(data?: IHearingAudioRecordingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['audio_file_links'])) {
                this.audio_file_links = [] as any;
                for (let item of _data['audio_file_links']) this.audio_file_links!.push(item);
            }
        }
    }

    static fromJS(data: any): HearingAudioRecordingResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingAudioRecordingResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.audio_file_links)) {
            data['audio_file_links'] = [];
            for (let item of this.audio_file_links) data['audio_file_links'].push(item);
        }
        return data;
    }
}

export interface IHearingAudioRecordingResponse {
    audio_file_links?: string[] | undefined;
}

export class HearingsForAudioFileSearchResponse implements IHearingsForAudioFileSearchResponse {
    /** Hearing Id */
    id?: string;
    /** The date and time for a hearing */
    scheduled_date_time?: Date;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    /** The courtroom account */
    courtroom_account?: string | undefined;
    /** The courtroom account */
    courtroom_account_name?: string | undefined;
    /** The hearing room name at the hearing venue */
    hearing_room_name?: string | undefined;

    constructor(data?: IHearingsForAudioFileSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.courtroom_account = _data['courtroom_account'];
            this.courtroom_account_name = _data['courtroom_account_name'];
            this.hearing_room_name = _data['hearing_room_name'];
        }
    }

    static fromJS(data: any): HearingsForAudioFileSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingsForAudioFileSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['courtroom_account'] = this.courtroom_account;
        data['courtroom_account_name'] = this.courtroom_account_name;
        data['hearing_room_name'] = this.hearing_room_name;
        return data;
    }
}

export interface IHearingsForAudioFileSearchResponse {
    /** Hearing Id */
    id?: string;
    /** The date and time for a hearing */
    scheduled_date_time?: Date;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    /** The courtroom account */
    courtroom_account?: string | undefined;
    /** The courtroom account */
    courtroom_account_name?: string | undefined;
    /** The hearing room name at the hearing venue */
    hearing_room_name?: string | undefined;
}

export class LinkedParticipant implements ILinkedParticipant {
    id?: string;
    participant_id?: string;
    linked_id?: string;
    type?: LinkedParticipantType;
    participant_contact_email?: string | undefined;
    linked_participant_contact_email?: string | undefined;

    constructor(data?: ILinkedParticipant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.participant_id = _data['participant_id'];
            this.linked_id = _data['linked_id'];
            this.type = _data['type'];
            this.participant_contact_email = _data['participant_contact_email'];
            this.linked_participant_contact_email = _data['linked_participant_contact_email'];
        }
    }

    static fromJS(data: any): LinkedParticipant {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedParticipant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['participant_id'] = this.participant_id;
        data['linked_id'] = this.linked_id;
        data['type'] = this.type;
        data['participant_contact_email'] = this.participant_contact_email;
        data['linked_participant_contact_email'] = this.linked_participant_contact_email;
        return data;
    }
}

export interface ILinkedParticipant {
    id?: string;
    participant_id?: string;
    linked_id?: string;
    type?: LinkedParticipantType;
    participant_contact_email?: string | undefined;
    linked_participant_contact_email?: string | undefined;
}

export class MultiHearingRequest implements IMultiHearingRequest {
    start_date?: Date;
    end_date?: Date;
    hearing_dates?: Date[] | undefined;
    is_individual_dates?: boolean;
    scheduled_duration?: number;

    constructor(data?: IMultiHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start_date = _data['start_date'] ? new Date(_data['start_date'].toString()) : <any>undefined;
            this.end_date = _data['end_date'] ? new Date(_data['end_date'].toString()) : <any>undefined;
            if (Array.isArray(_data['hearing_dates'])) {
                this.hearing_dates = [] as any;
                for (let item of _data['hearing_dates']) this.hearing_dates!.push(new Date(item));
            }
            this.is_individual_dates = _data['is_individual_dates'];
            this.scheduled_duration = _data['scheduled_duration'];
        }
    }

    static fromJS(data: any): MultiHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MultiHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['start_date'] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data['end_date'] = this.end_date ? this.end_date.toISOString() : <any>undefined;
        if (Array.isArray(this.hearing_dates)) {
            data['hearing_dates'] = [];
            for (let item of this.hearing_dates) data['hearing_dates'].push(item.toISOString());
        }
        data['is_individual_dates'] = this.is_individual_dates;
        data['scheduled_duration'] = this.scheduled_duration;
        return data;
    }
}

export interface IMultiHearingRequest {
    start_date?: Date;
    end_date?: Date;
    hearing_dates?: Date[] | undefined;
    is_individual_dates?: boolean;
    scheduled_duration?: number;
}

export class PhoneConferenceResponse implements IPhoneConferenceResponse {
    telephone_conference_id?: string | undefined;

    constructor(data?: IPhoneConferenceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.telephone_conference_id = _data['telephone_conference_id'];
        }
    }

    static fromJS(data: any): PhoneConferenceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneConferenceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['telephone_conference_id'] = this.telephone_conference_id;
        return data;
    }
}

export interface IPhoneConferenceResponse {
    telephone_conference_id?: string | undefined;
}

export class UpdateBookingStatusResponse implements IUpdateBookingStatusResponse {
    success?: boolean;
    message?: string | undefined;
    telephone_conference_id?: string | undefined;

    constructor(data?: IUpdateBookingStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data['success'];
            this.message = _data['message'];
            this.telephone_conference_id = _data['telephone_conference_id'];
        }
    }

    static fromJS(data: any): UpdateBookingStatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBookingStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['success'] = this.success;
        data['message'] = this.message;
        data['telephone_conference_id'] = this.telephone_conference_id;
        return data;
    }
}

export interface IUpdateBookingStatusResponse {
    success?: boolean;
    message?: string | undefined;
    telephone_conference_id?: string | undefined;
}

export class UploadNonWorkingHoursResponse implements IUploadNonWorkingHoursResponse {
    failed_usernames?: string[] | undefined;

    constructor(data?: IUploadNonWorkingHoursResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['failed_usernames'])) {
                this.failed_usernames = [] as any;
                for (let item of _data['failed_usernames']) this.failed_usernames!.push(item);
            }
        }
    }

    static fromJS(data: any): UploadNonWorkingHoursResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadNonWorkingHoursResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.failed_usernames)) {
            data['failed_usernames'] = [];
            for (let item of this.failed_usernames) data['failed_usernames'].push(item);
        }
        return data;
    }
}

export interface IUploadNonWorkingHoursResponse {
    failed_usernames?: string[] | undefined;
}

export class UploadWorkHoursResponse implements IUploadWorkHoursResponse {
    failed_usernames?: string[] | undefined;

    constructor(data?: IUploadWorkHoursResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['failed_usernames'])) {
                this.failed_usernames = [] as any;
                for (let item of _data['failed_usernames']) this.failed_usernames!.push(item);
            }
        }
    }

    static fromJS(data: any): UploadWorkHoursResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadWorkHoursResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.failed_usernames)) {
            data['failed_usernames'] = [];
            for (let item of this.failed_usernames) data['failed_usernames'].push(item);
        }
        return data;
    }
}

export interface IUploadWorkHoursResponse {
    failed_usernames?: string[] | undefined;
}

export enum BookingStatus2 {
    Booked = 'Booked',
    Created = 'Created',
    Cancelled = 'Cancelled',
    Failed = 'Failed',
    BookedWithoutJudge = 'BookedWithoutJudge',
    ConfirmedWithoutJudge = 'ConfirmedWithoutJudge'
}

export class EditJusticeUserRequest implements IEditJusticeUserRequest {
    id?: string;
    username?: string | undefined;
    roles?: JusticeUserRole[] | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    contact_telephone?: string | undefined;

    constructor(data?: IEditJusticeUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.username = _data['username'];
            if (Array.isArray(_data['roles'])) {
                this.roles = [] as any;
                for (let item of _data['roles']) this.roles!.push(item);
            }
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.contact_telephone = _data['contact_telephone'];
        }
    }

    static fromJS(data: any): EditJusticeUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditJusticeUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['username'] = this.username;
        if (Array.isArray(this.roles)) {
            data['roles'] = [];
            for (let item of this.roles) data['roles'].push(item);
        }
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['contact_telephone'] = this.contact_telephone;
        return data;
    }
}

export interface IEditJusticeUserRequest {
    id?: string;
    username?: string | undefined;
    roles?: JusticeUserRole[] | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    contact_telephone?: string | undefined;
}

export enum JusticeUserRole {
    CaseAdmin = 'CaseAdmin',
    Vho = 'Vho',
    Clerk = 'Clerk',
    Judge = 'Judge',
    Individual = 'Individual',
    Representative = 'Representative',
    JudicialOfficeHolder = 'JudicialOfficeHolder',
    StaffMember = 'StaffMember',
    VhTeamLead = 'VhTeamLead'
}

export class NonWorkingHours implements INonWorkingHours {
    id?: number;
    start_time?: Date;
    end_time?: Date;

    constructor(data?: INonWorkingHours) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.start_time = _data['start_time'] ? new Date(_data['start_time'].toString()) : <any>undefined;
            this.end_time = _data['end_time'] ? new Date(_data['end_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NonWorkingHours {
        data = typeof data === 'object' ? data : {};
        let result = new NonWorkingHours();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['start_time'] = this.start_time ? this.start_time.toISOString() : <any>undefined;
        data['end_time'] = this.end_time ? this.end_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface INonWorkingHours {
    id?: number;
    start_time?: Date;
    end_time?: Date;
}

export class RestoreJusticeUserRequest implements IRestoreJusticeUserRequest {
    id?: string;
    username?: string | undefined;

    constructor(data?: IRestoreJusticeUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.username = _data['username'];
        }
    }

    static fromJS(data: any): RestoreJusticeUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RestoreJusticeUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['username'] = this.username;
        return data;
    }
}

export interface IRestoreJusticeUserRequest {
    id?: string;
    username?: string | undefined;
}

export class UpdateHearingAllocationToCsoRequest implements IUpdateHearingAllocationToCsoRequest {
    hearings?: string[] | undefined;
    cso_id?: string;

    constructor(data?: IUpdateHearingAllocationToCsoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['hearings'])) {
                this.hearings = [] as any;
                for (let item of _data['hearings']) this.hearings!.push(item);
            }
            this.cso_id = _data['cso_id'];
        }
    }

    static fromJS(data: any): UpdateHearingAllocationToCsoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHearingAllocationToCsoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hearings)) {
            data['hearings'] = [];
            for (let item of this.hearings) data['hearings'].push(item);
        }
        data['cso_id'] = this.cso_id;
        return data;
    }
}

export interface IUpdateHearingAllocationToCsoRequest {
    hearings?: string[] | undefined;
    cso_id?: string;
}

export class UpdateNonWorkingHoursRequest implements IUpdateNonWorkingHoursRequest {
    hours?: NonWorkingHours[] | undefined;

    constructor(data?: IUpdateNonWorkingHoursRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['hours'])) {
                this.hours = [] as any;
                for (let item of _data['hours']) this.hours!.push(NonWorkingHours.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNonWorkingHoursRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNonWorkingHoursRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hours)) {
            data['hours'] = [];
            for (let item of this.hours) data['hours'].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateNonWorkingHoursRequest {
    hours?: NonWorkingHours[] | undefined;
}

export class UploadNonWorkingHoursRequest implements IUploadNonWorkingHoursRequest {
    username?: string | undefined;
    end_time?: Date;
    start_time?: Date;

    constructor(data?: IUploadNonWorkingHoursRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data['username'];
            this.end_time = _data['end_time'] ? new Date(_data['end_time'].toString()) : <any>undefined;
            this.start_time = _data['start_time'] ? new Date(_data['start_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UploadNonWorkingHoursRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadNonWorkingHoursRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['username'] = this.username;
        data['end_time'] = this.end_time ? this.end_time.toISOString() : <any>undefined;
        data['start_time'] = this.start_time ? this.start_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUploadNonWorkingHoursRequest {
    username?: string | undefined;
    end_time?: Date;
    start_time?: Date;
}

export class UploadWorkHoursRequest implements IUploadWorkHoursRequest {
    username?: string | undefined;
    working_hours?: WorkingHours[] | undefined;

    constructor(data?: IUploadWorkHoursRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data['username'];
            if (Array.isArray(_data['working_hours'])) {
                this.working_hours = [] as any;
                for (let item of _data['working_hours']) this.working_hours!.push(WorkingHours.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadWorkHoursRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadWorkHoursRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['username'] = this.username;
        if (Array.isArray(this.working_hours)) {
            data['working_hours'] = [];
            for (let item of this.working_hours) data['working_hours'].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadWorkHoursRequest {
    username?: string | undefined;
    working_hours?: WorkingHours[] | undefined;
}

export class WorkingHours implements IWorkingHours {
    day_of_week_id?: number;
    end_time_hour?: number | undefined;
    end_time_minutes?: number | undefined;
    start_time_hour?: number | undefined;
    start_time_minutes?: number | undefined;
    readonly start_time?: string | undefined;
    readonly end_time?: string | undefined;

    constructor(data?: IWorkingHours) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day_of_week_id = _data['day_of_week_id'];
            this.end_time_hour = _data['end_time_hour'];
            this.end_time_minutes = _data['end_time_minutes'];
            this.start_time_hour = _data['start_time_hour'];
            this.start_time_minutes = _data['start_time_minutes'];
            (<any>this).start_time = _data['start_time'];
            (<any>this).end_time = _data['end_time'];
        }
    }

    static fromJS(data: any): WorkingHours {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingHours();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['day_of_week_id'] = this.day_of_week_id;
        data['end_time_hour'] = this.end_time_hour;
        data['end_time_minutes'] = this.end_time_minutes;
        data['start_time_hour'] = this.start_time_hour;
        data['start_time_minutes'] = this.start_time_minutes;
        data['start_time'] = this.start_time;
        data['end_time'] = this.end_time;
        return data;
    }
}

export interface IWorkingHours {
    day_of_week_id?: number;
    end_time_hour?: number | undefined;
    end_time_minutes?: number | undefined;
    start_time_hour?: number | undefined;
    start_time_minutes?: number | undefined;
    start_time?: string | undefined;
    end_time?: string | undefined;
}

export class HearingVenueResponse implements IHearingVenueResponse {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IHearingVenueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.code = _data['code'];
        }
    }

    static fromJS(data: any): HearingVenueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingVenueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['code'] = this.code;
        return data;
    }
}

export interface IHearingVenueResponse {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
}

export class HearingsByUsernameForDeletionResponse implements IHearingsByUsernameForDeletionResponse {
    hearing_id?: string;
    scheduled_date_time?: Date;
    case_name?: string | undefined;
    case_number?: string | undefined;
    venue?: string | undefined;

    constructor(data?: IHearingsByUsernameForDeletionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hearing_id = _data['hearing_id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_name = _data['case_name'];
            this.case_number = _data['case_number'];
            this.venue = _data['venue'];
        }
    }

    static fromJS(data: any): HearingsByUsernameForDeletionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingsByUsernameForDeletionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['hearing_id'] = this.hearing_id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_name'] = this.case_name;
        data['case_number'] = this.case_number;
        data['venue'] = this.venue;
        return data;
    }
}

export interface IHearingsByUsernameForDeletionResponse {
    hearing_id?: string;
    scheduled_date_time?: Date;
    case_name?: string | undefined;
    case_number?: string | undefined;
    venue?: string | undefined;
}

export class JusticeUserResponse implements IJusticeUserResponse {
    id?: string;
    first_name?: string | undefined;
    lastname?: string | undefined;
    contact_email?: string | undefined;
    username?: string | undefined;
    telephone?: string | undefined;
    user_roles?: JusticeUserRole[] | undefined;
    is_vh_team_leader?: boolean;
    created_by?: string | undefined;
    full_name?: string | undefined;
    deleted?: boolean;

    constructor(data?: IJusticeUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.first_name = _data['first_name'];
            this.lastname = _data['lastname'];
            this.contact_email = _data['contact_email'];
            this.username = _data['username'];
            this.telephone = _data['telephone'];
            if (Array.isArray(_data['user_roles'])) {
                this.user_roles = [] as any;
                for (let item of _data['user_roles']) this.user_roles!.push(item);
            }
            this.is_vh_team_leader = _data['is_vh_team_leader'];
            this.created_by = _data['created_by'];
            this.full_name = _data['full_name'];
            this.deleted = _data['deleted'];
        }
    }

    static fromJS(data: any): JusticeUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JusticeUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['first_name'] = this.first_name;
        data['lastname'] = this.lastname;
        data['contact_email'] = this.contact_email;
        data['username'] = this.username;
        data['telephone'] = this.telephone;
        if (Array.isArray(this.user_roles)) {
            data['user_roles'] = [];
            for (let item of this.user_roles) data['user_roles'].push(item);
        }
        data['is_vh_team_leader'] = this.is_vh_team_leader;
        data['created_by'] = this.created_by;
        data['full_name'] = this.full_name;
        data['deleted'] = this.deleted;
        return data;
    }
}

export interface IJusticeUserResponse {
    id?: string;
    first_name?: string | undefined;
    lastname?: string | undefined;
    contact_email?: string | undefined;
    username?: string | undefined;
    telephone?: string | undefined;
    user_roles?: JusticeUserRole[] | undefined;
    is_vh_team_leader?: boolean;
    created_by?: string | undefined;
    full_name?: string | undefined;
    deleted?: boolean;
}

export class VhoNonAvailabilityWorkHoursResponse implements IVhoNonAvailabilityWorkHoursResponse {
    id?: number;
    end_time?: Date;
    start_time?: Date;

    constructor(data?: IVhoNonAvailabilityWorkHoursResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.end_time = _data['end_time'] ? new Date(_data['end_time'].toString()) : <any>undefined;
            this.start_time = _data['start_time'] ? new Date(_data['start_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VhoNonAvailabilityWorkHoursResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VhoNonAvailabilityWorkHoursResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['end_time'] = this.end_time ? this.end_time.toISOString() : <any>undefined;
        data['start_time'] = this.start_time ? this.start_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVhoNonAvailabilityWorkHoursResponse {
    id?: number;
    end_time?: Date;
    start_time?: Date;
}

export class VhoWorkHoursResponse implements IVhoWorkHoursResponse {
    day_of_week_id?: number;
    day_of_week?: string | undefined;
    start_time?: string | undefined;
    end_time?: string | undefined;

    constructor(data?: IVhoWorkHoursResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day_of_week_id = _data['day_of_week_id'];
            this.day_of_week = _data['day_of_week'];
            this.start_time = _data['start_time'];
            this.end_time = _data['end_time'];
        }
    }

    static fromJS(data: any): VhoWorkHoursResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VhoWorkHoursResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['day_of_week_id'] = this.day_of_week_id;
        data['day_of_week'] = this.day_of_week;
        data['start_time'] = this.start_time;
        data['end_time'] = this.end_time;
        return data;
    }
}

export interface IVhoWorkHoursResponse {
    day_of_week_id?: number;
    day_of_week?: string | undefined;
    start_time?: string | undefined;
    end_time?: string | undefined;
}

export class PersonResponseV2 implements IPersonResponseV2 {
    id?: string;
    title?: string | undefined;
    first_name?: string | undefined;
    middle_names?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    telephone_number?: string | undefined;
    username?: string | undefined;
    organisation?: string | undefined;

    constructor(data?: IPersonResponseV2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.title = _data['title'];
            this.first_name = _data['first_name'];
            this.middle_names = _data['middle_names'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.telephone_number = _data['telephone_number'];
            this.username = _data['username'];
            this.organisation = _data['organisation'];
        }
    }

    static fromJS(data: any): PersonResponseV2 {
        data = typeof data === 'object' ? data : {};
        let result = new PersonResponseV2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['title'] = this.title;
        data['first_name'] = this.first_name;
        data['middle_names'] = this.middle_names;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['telephone_number'] = this.telephone_number;
        data['username'] = this.username;
        data['organisation'] = this.organisation;
        return data;
    }
}

export interface IPersonResponseV2 {
    id?: string;
    title?: string | undefined;
    first_name?: string | undefined;
    middle_names?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    telephone_number?: string | undefined;
    username?: string | undefined;
    organisation?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property)) this[property] = _data[property];
            }
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property)) data[property] = this[property];
        }
        data['type'] = this.type;
        data['title'] = this.title;
        data['status'] = this.status;
        data['detail'] = this.detail;
        data['instance'] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ValidationProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[] } | undefined;
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property)) this[property] = _data[property];
            }
            if (_data['errors']) {
                this.errors = {} as any;
                for (let key in _data['errors']) {
                    if (_data['errors'].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data['errors'][key] !== undefined ? _data['errors'][key] : [];
                }
            }
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property)) data[property] = this[property];
        }
        if (this.errors) {
            data['errors'] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key)) (<any>data['errors'])[key] = (<any>this.errors)[key];
            }
        }
        data['type'] = this.type;
        data['title'] = this.title;
        data['status'] = this.status;
        data['detail'] = this.detail;
        data['instance'] = this.instance;
        return data;
    }
}

export interface IValidationProblemDetails {
    errors?: { [key: string]: string[] } | undefined;
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class BookHearingException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isBookHearingException = true;

    static isBookHearingException(obj: any): obj is BookHearingException {
        return obj.isBookHearingException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): Observable<any> {
    return _observableThrow(new BookHearingException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next('');
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
